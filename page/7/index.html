<!doctype html><html><head><title>超的博客</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="超的博客"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:locale" content="zh"><meta property="og:url" content="https://dccmmtop.github.io/"><link href=https://dccmmtop.github.io/index.xml rel=alternate type=application/rss+xml title=超的博客><link rel=icon type=image/x-icon href=../../favicon.ico><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<link href=https://dccmmtop.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://dccmmtop.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://dccmmtop.github.io/css/style.css><link rel=stylesheet href=https://dccmmtop.github.io/css/custom.css><link rel=stylesheet href=https://dccmmtop.github.io/css/copy-to-clipboard.css><script src=https://dccmmtop.github.io/js/fastsearch.js></script>
<script src=https://dccmmtop.github.io/js/fuse.js></script>
<script src=https://dccmmtop.github.io/js/custom.js></script>
<script src=https://dccmmtop.github.io/js/copy-to-clipboard.js></script><meta name=generator content="Hugo 0.105.0"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=https://dccmmtop.github.io/>超的博客</a><nav id=main-nav><a class=main-nav-link href=../../posts/>文章</a>
<a class=main-nav-link href=../../tags/>标签</a>
<a class=main-nav-link href=../../about/>关于</a>
<a class=main-nav-link id=search><input id=inputSearch placeholder=search><svg t="1634282825021" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="2401" width="15" height="15"><path d="M1005.312 914.752 806.784 716.288A448 448 0 100 448a448 448 0 00716.288 358.784l198.4 198.4a64 64 0 1090.624-90.432zM448 767.936A320 320 0 11448 128a320 320 0 010 640z" fill="#262626" p-id="2402"/></svg></a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div><div class="modal fade" id=exampleModal tabindex=-1 role=dialog aria-labelledby=exampleModalLabel aria-hidden=true><div class=modal-dialog role=document><div class=modal-content><div class=modal-header><h5 class=modal-title id=exampleModalLabel>搜索结果</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class="modal-body searchResults"></div></div></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%8E%B0%E6%B6%88%E6%81%AF/>利用cookie实现闪现消息</a></h1></header><div class=article-meta><a href=../../posts/%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%8E%B0%E6%B6%88%E6%81%AF/ class=article-date><time datetime=2021-10-28T23:20:50.000+00:00 itemprop=datePublished>2021-10-28</time></a></div><div class=article-entry itemprop=articleBody><p>为了向用户报告某个动作的执行情况，应用程序有时候会向用户展示一条简短的通知消息， 比如说，如果一个用户尝试在论坛上发表一篇帖子，但是这篇帖子因为某种原因而发表失败了，那么论坛应该向这个用户展示一条帖子发</p><p class=article-more-link><a href=../../posts/%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%8E%B0%E6%B6%88%E6%81%AF/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/go>go</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E8%AF%B7%E6%B1%82%E4%BD%93/>解析请求头和请求体</a></h1></header><div class=article-meta><a href=../../posts/%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E8%AF%B7%E6%B1%82%E4%BD%93/ class=article-date><time datetime=2021-10-28T00:19:44.000+00:00 itemprop=datePublished>2021-10-28</time></a></div><div class=article-entry itemprop=articleBody><p>解析请求头 // 解析请求头 func headers(w http.ResponseWriter, request *http.Request) { // 获取所欲请求头，Header 是个 map, key 是字符串，value 是字符串切片 headers := request.Header fmt.Printf("所有请求头headers: %v\n", headers) // 获取单个请求头,返回的是字</p><p class=article-more-link><a href=../../posts/%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E8%AF%B7%E6%B1%82%E4%BD%93/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/go>go</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%9F%90%E4%BA%9B%E5%8F%82%E6%95%B0%E6%94%BE%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD/>为什么把某些参数放在请求头中</a></h1></header><div class=article-meta><a href=../../posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%9F%90%E4%BA%9B%E5%8F%82%E6%95%B0%E6%94%BE%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD/ class=article-date><time datetime=2021-10-27T22:12:48.000+00:00 itemprop=datePublished>2021-10-27</time></a></div><div class=article-entry itemprop=articleBody><p>在HTTP协议中，首部和请求体是分开传输的，将一些认证信息参数放在请求头中，服务端先解析请求头，如果认证不通过，可以直接返回认证失败，不用再传输请求体，从而提高服务器的性能。 下面做实验验证,实验思路：</p><p class=article-more-link><a href=../../posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%9F%90%E4%BA%9B%E5%8F%82%E6%95%B0%E6%94%BE%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/htttp>HTTTP</a></li><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/go>go</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/cookie%E6%93%8D%E4%BD%9C/>Cookie操作</a></h1></header><div class=article-meta><a href=../../posts/cookie%E6%93%8D%E4%BD%9C/ class=article-date><time datetime=2021-10-26T23:32:10.000+00:00 itemprop=datePublished>2021-10-26</time></a></div><div class=article-entry itemprop=articleBody><p>将 cookie 发送给至客户端 Cookie结构的string方法可以返回一个经过序列化处理的cookie，其中Set-Cookie响应首部的值就是由这些序列化之后的cookie组成的。 package main import "net/http" func main(){ server := http.Server{ Addr: "127.0.0.1:8080", } http.HandleFunc("/setCookie",setCookie) server.ListenAndServe()</p><p class=article-more-link><a href=../../posts/cookie%E6%93%8D%E4%BD%9C/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/go>go</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/cookie%E6%A6%82%E8%A7%88/>Cookie概览</a></h1></header><div class=article-meta><a href=../../posts/cookie%E6%A6%82%E8%A7%88/ class=article-date><time datetime=2021-10-26T23:28:06.000+00:00 itemprop=datePublished>2021-10-26</time></a></div><div class=article-entry itemprop=articleBody><p>会话 cookie 与持久 cookie 没有设置Expires字段的cookie通常称为会话cookie或者临时cookie，这种cookie在浏览器关闭的时候就会自动被移除。相对而言，设置了Expires字段的cookie通</p><p class=article-more-link><a href=../../posts/cookie%E6%A6%82%E8%A7%88/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/http>HTTP</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8/>设置响应首部及响应体示例</a></h1></header><div class=article-meta><a href=../../posts/%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8/ class=article-date><time datetime=2021-10-26T22:54:48.000+00:00 itemprop=datePublished>2021-10-26</time></a></div><div class=article-entry itemprop=articleBody><p>返回体 func writeExample(w http.ResponseWriter, request *http.Request) { // 没有手动设置响应类型，会通过检测响应的前 512 个字节自动判断响应类型 // 这里是 Content-Type: text/html; charset=utf-8 str:= `&lt;html> &lt;head>&lt;title>Go Web Programming&lt;/title>&lt;/head> &lt;body>&lt;hl>Hello World&lt;/hl>&lt;/body> &lt;/html>` w.Write([]byte(str)) } 设置状态码 func writeHeaderExample(w http.ResponseWriter, request *http.Request) { // 设置HTTP 状态码, WriteHeader 方法名有误导，只能设置状态码，而不是</p><p class=article-more-link><a href=../../posts/%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/go>go</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A7%81%E9%92%A5/>生成证书及服务端私钥</a></h1></header><div class=article-meta><a href=../../posts/%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A7%81%E9%92%A5/ class=article-date><time datetime=2021-10-25T22:02:11.000+00:00 itemprop=datePublished>2021-10-25</time></a></div><div class=article-entry itemprop=articleBody><p>package main import ( "crypto/rand" "crypto/rsa" "crypto/x509" "crypto/x509/pkix" "encoding/pem" "math/big" "net" "os" "time" ) func main(){ max := new(big.Int).Lsh(big.NewInt(1), 128) serialNumber, _ := rand.Int(rand.Reader,max) subject := pkix.Name{ Organization: []string {"YX"}, OrganizationalUnit: []string {"YX"}, CommonName: "DC", } template := x509.Certificate{ SerialNumber: serialNumber, Subject: subject, NotBefore: time.Now(), NotAfter: time.Now().Add(365 * 24 * time.Hour), KeyUsage: x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature, ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth}, IPAddresses: []net.IP{net.ParseIP("127.0.0.1")}, } pk, _ := rsa.GenerateKey(rand.Reader,2048) derBytes , _ := x509.CreateCertificate(rand.Reader, &template, &template, &pk.PublicKey, pk) cerOut, _ := os.Create("cert.pem") pem.Encode(cerOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes}) cerOut.Close() keyOut , _ := os.Create("key.pem") pem.Encode(keyOut, &pem.Block{Type: "RAS PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(pk)}) keyOut.Close() }</p><p class=article-more-link><a href=../../posts/%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A7%81%E9%92%A5/></a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/http%E6%A6%82%E8%A7%88/>HTTP概览</a></h1></header><div class=article-meta><a href=../../posts/http%E6%A6%82%E8%A7%88/ class=article-date><time datetime=2021-10-24T22:17:14.000+00:00 itemprop=datePublished>2021-10-24</time></a></div><div class=article-entry itemprop=articleBody><p>什么是无状态 因为HTTP是一种无连接协议（connection-less protocol），通过这种协议发送给服务器的请求对服务器之前处理过的请求一无所知，所以应用程序才会以cookie的方式在客户端</p><p class=article-more-link><a href=../../posts/http%E6%A6%82%E8%A7%88/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/http>HTTP</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/linux_nobody%E7%94%A8%E6%88%B7/>Linux_nobody用户</a></h1></header><div class=article-meta><a href=../../posts/linux_nobody%E7%94%A8%E6%88%B7/ class=article-date><time datetime=2021-10-21T17:30:36.000+00:00 itemprop=datePublished>2021-10-21</time></a></div><div class=article-entry itemprop=articleBody><p>nobody在linux中是一个不能登陆的帐号，一些服务进程如apache，aquid等都采用一些特殊的帐号来运行，比如nobody,news,games等等，这是就可以防止程序本身有安全问题的时候，</p><p class=article-more-link><a href=../../posts/linux_nobody%E7%94%A8%E6%88%B7/></a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/elasticsearch%E8%AE%A4%E7%9F%A5/>ElasticSearch认知</a></h1></header><div class=article-meta><a href=../../posts/elasticsearch%E8%AE%A4%E7%9F%A5/ class=article-date><time datetime=2021-10-18T23:23:43.000+00:00 itemprop=datePublished>2021-10-18</time></a></div><div class=article-entry itemprop=articleBody><p>概览 为了理解Elasticsearch中数据是如何组织的，从以下两个角度来观察 逻辑设计 搜索应用所要注意的。用于索引和搜索的基本单位是文档，可以将其认为 文档以类型来分组，类型包含若干文档， 类似表格包含若</p><p class=article-more-link><a href=../../posts/elasticsearch%E8%AE%A4%E7%9F%A5/></a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/https%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/>HTTPS自签证书</a></h1></header><div class=article-meta><a href=../../posts/https%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/ class=article-date><time datetime=2021-10-17T09:59:49.000+00:00 itemprop=datePublished>2021-10-17</time></a></div><div class=article-entry itemprop=articleBody><p></p><p class=article-more-link><a href=../../posts/https%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/></a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3/>Mongo创建文档</a></h1></header><div class=article-meta><a href=../../posts/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3/ class=article-date><time datetime=2021-09-05T17:46:38.000+00:00 itemprop=datePublished>2021-09-05</time></a></div><div class=article-entry itemprop=articleBody><p>插入并保存文档 db.foo.insert({"bar": "baz"}) 这个操作会给文档自动增加一个"_id"键（要是原来没有的话），然后将其保存到MongoDB中。 批量插入 如果要向集合中插入多个文档，使用批量插入会快一些。使用批量插</p><p class=article-more-link><a href=../../posts/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/mongodb>mongoDB</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/mongo_shell%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/>Mongo_Shell基础操作</a></h1></header><div class=article-meta><a href=../../posts/mongo_shell%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/ class=article-date><time datetime=2021-09-05T17:36:12.000+00:00 itemprop=datePublished>2021-09-05</time></a></div><div class=article-entry itemprop=articleBody><p>运行shell MongoDB自带JavaScript shell，可在shell中使用命令行与MongoDB实例交互。 shell是一个功能完备的JavaScript解释器，可运行任意JavaScript</p><p class=article-more-link><a href=../../posts/mongo_shell%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/></a></p></div></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/mongodb%E5%9F%BA%E7%A1%80/>MongoDB基础</a></h1></header><div class=article-meta><a href=../../posts/mongodb%E5%9F%BA%E7%A1%80/ class=article-date><time datetime=2021-09-05T16:47:25.000+00:00 itemprop=datePublished>2021-09-05</time></a></div><div class=article-entry itemprop=articleBody><p>文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。 类似地，集合（collection）可以看作是一个拥有动态模式（dynamic schema）的表。 MongoD</p><p class=article-more-link><a href=../../posts/mongodb%E5%9F%BA%E7%A1%80/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/mongodb>mongoDB</a></li></ul></footer></div></article><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 itemprop=name><a class=article-title href=../../posts/go_mod%E7%9A%84%E4%BD%BF%E7%94%A8/>go_mod的使用</a></h1></header><div class=article-meta><a href=../../posts/go_mod%E7%9A%84%E4%BD%BF%E7%94%A8/ class=article-date><time datetime=2021-08-18T16:23:14.000+00:00 itemprop=datePublished>2021-08-18</time></a></div><div class=article-entry itemprop=articleBody><p>Go 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。 从</p><p class=article-more-link><a href=../../posts/go_mod%E7%9A%84%E4%BD%BF%E7%94%A8/></a></p></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/go>go</a></li></ul></footer></div></article><nav id=page-nav><a href=../../page/6/ rel=prev class="extend prev">&#171;</a>
<a href=../../>1</a>
<a href=../../page/2/>2</a>
<a href=../../page/3/>3</a>
<a href=../../page/4/>4</a>
<a href=../../page/5/>5</a>
<a href=../../page/6/>6</a>
<span class="page-number current">7</span>
<a href=../../page/8/>8</a>
<a href=../../page/9/>9</a>
<a href=../../page/10/>10</a>
<a href=../../page/11/>11</a>
<a href=../../page/12/>12</a>
<a href=../../page/8/ rel=next class="extend next">&#187;</a></nav></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022 dc<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script><script>document.getElementById("main-nav-toggle").addEventListener("click",function(){var e=document.getElementById("header");e.classList.contains("mobile-on")?e.classList.remove("mobile-on"):e.classList.add("mobile-on")})</script></footer></div></body></html>