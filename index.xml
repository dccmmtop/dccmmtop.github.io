<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>超的博客</title>
    <link>https://dccmmtop.github.io/</link>
    <description>Recent content on 超的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>dccmmtop@foxmail.com (dc)</managingEditor>
    <webMaster>dccmmtop@foxmail.com (dc)</webMaster>
    <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
    <lastBuildDate>Thu, 07 Jul 2022 23:08:21 +0000</lastBuildDate><atom:link href="https://dccmmtop.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RabbitMQ中的内存节点与磁盘节点</title>
      <link>https://dccmmtop.github.io/posts/rabbitmq%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E8%8A%82%E7%82%B9%E4%B8%8E%E7%A3%81%E7%9B%98%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 07 Jul 2022 23:08:21 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rabbitmq%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E8%8A%82%E7%82%B9%E4%B8%8E%E7%A3%81%E7%9B%98%E8%8A%82%E7%82%B9/</guid>
      <description>每个RabbitMQ 节点只有两种类型，要么是内存节点，要么是磁盘节点 内存节点 内存节点将所有的队列、交换器、绑定、用户、权限和vhost的元数据定义都仅存储在内存中. 显而易见，内存节点拥有更出色的性能 磁</description>
    </item>
    
    <item>
      <title>RabbitMQ集群中的交换器</title>
      <link>https://dccmmtop.github.io/posts/rabbitmq%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%8D%A2%E5%99%A8/</link>
      <pubDate>Thu, 07 Jul 2022 22:58:26 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rabbitmq%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%8D%A2%E5%99%A8/</guid>
      <description>交换器不像队列那样有真实的进程， 它只是一张名称与队列进程PID的关系表 当你将消息发布到交换器时，实际上是由你所连接到的信道将消息上的路由键同交换器的绑定列表进行比较，然后路由消息。正是信道（chann</description>
    </item>
    
    <item>
      <title>集群中的队列</title>
      <link>https://dccmmtop.github.io/posts/%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 07 Jul 2022 00:22:11 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97/</guid>
      <description>从直觉上来看,一说到集群，我们就联想到高可用，一个节点宕机了，不会影响整体服务，客户端会从其他节点拿数据。比如 ES, Redis, mongoDB 等的集群都是符合直觉的架构。 但是，事情到了rabbitMQ 这里，却完全不一样了。 在将</description>
    </item>
    
    <item>
      <title>RabbitMQ集群部署</title>
      <link>https://dccmmtop.github.io/posts/rabbitmq%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 04 Jul 2022 22:27:10 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rabbitmq%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</guid>
      <description>本文采用docker-compose 的方式部署 rabbitMQ集群 docker-compose.yml version: &amp;#34;3&amp;#34; services: rabbitmq: restart: always container_name: rabbitMQ image: rabbitmq:3.7.7-management # 注意 hostname（本地域名）, rabbitMQ集群之间的通信就是靠此寻址的。物理机部署时也可以使用固定IP</description>
    </item>
    
    <item>
      <title>RabbitMQ应答队列</title>
      <link>https://dccmmtop.github.io/posts/%E5%BA%94%E7%AD%94%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 27 Jun 2022 22:57:24 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%BA%94%E7%AD%94%E9%98%9F%E5%88%97/</guid>
      <description>生产者在某个队列上等待消费者返回的消息， 这个队列被称为应答队列,RabbitMQ 天生支持应答队列的机制。 什么时候需要应答队列 当一条消息被消费者处理后，需要告知生产者一些信息时，消费者就需要在应答队列上</description>
    </item>
    
    <item>
      <title>powershell配置</title>
      <link>https://dccmmtop.github.io/posts/powershell%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 13 May 2022 17:28:48 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/powershell%E9%85%8D%E7%BD%AE/</guid>
      <description>安装powershell 下载地址 安装scoop 打开powershell 执行 修改策略 set-executionpolicy remotesigned -s cu 安装scoop iex (new-object net.webclient).downloadstring(&#39;https://get.scoop.sh&#39;) 自动补全 PSReadLine 在 V5 或以上版本中自带 命令 $profile 可见看见配置文件的路径，如果没有此文件，新建即可 打配置</description>
    </item>
    
    <item>
      <title>awk分组统计</title>
      <link>https://dccmmtop.github.io/posts/awk%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1/</link>
      <pubDate>Tue, 10 May 2022 15:51:00 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/awk%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1/</guid>
      <description>Shell学习笔记：awk实现group by分组统计功能 日常部分数据以 txt 的文件格式提供，为避免入库之后再进行统计的麻烦，故学习 shell 进行处理，减少工作量。 1.样例数据 test.txt YD5Gxxx|6618151|68</description>
    </item>
    
    <item>
      <title>golnag插件式开发的一种案例</title>
      <link>https://dccmmtop.github.io/posts/golnag%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E7%A7%8D%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Sun, 08 May 2022 22:06:51 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/golnag%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E7%A7%8D%E6%A1%88%E4%BE%8B/</guid>
      <description>OCP：开闭原则 软件的5大设计原则 “SOLID” 原则,其中之一就是 OCP(开闭原则) 该设计原则是由Bertrand Meyer在20世纪80年代大力推广的，其核心要素是：如果软件系统想要更容易被改变，那</description>
    </item>
    
    <item>
      <title>右键注册自定义程序</title>
      <link>https://dccmmtop.github.io/posts/%E5%8F%B3%E9%94%AE%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 08 May 2022 16:39:06 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%8F%B3%E9%94%AE%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A8%8B%E5%BA%8F/</guid>
      <description>想把自己写的一个控制台程序添加到右键，可以通过修改注册表的方式实现，但是修改起来比较麻烦，推荐使用右键管理器进行修改 右侧的 ”文件“ ”文件夹“ ”目录“ 等，代表在该项右键时，右键菜单显示的内容 点击 + 新建：</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘八——软件架构</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E5%85%AB%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 05 May 2022 22:29:49 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E5%85%AB%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</guid>
      <description>软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。 (拆分、组合、通信) 目标 设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘七——设计原则</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%B8%83%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 May 2022 10:45:55 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%B8%83%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>SOLID 原则 SRP：单一职责原则。 该设计原则是基于康威定律（Conway&amp;rsquo;s Law）[1]的一个推论——一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘六——函数式编程</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E5%85%AD%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 03 May 2022 16:43:03 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E5%85%AD%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程所依赖的原理，在很多方面其实是早于编程本身出现的。因为函数式编程这种范式强烈依赖于Alonzo Church在20世纪30年代发明的λ演算。 什么是函数式编程 举个例子：计算0-25范围内整数的平</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘五——面向对象</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%BA%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 02 May 2022 23:29:24 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%BA%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>譬如封装（encapsulation）、继承（inheritance）、多态（polymorphism）。其隐含意思就是说面向对象编程是这三项的有机组合，或者任何一种支持面向对象的编程语言必须支持这三</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘四——结构化编程</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E5%9B%9B%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 02 May 2022 23:13:43 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E5%9B%9B%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/</guid>
      <description>科学方法论不需要证明某条结论是正确的，只需要想办法证明它是错误的。如果某个结论经过一定的努力无法证伪，我们则认为它在当下是足够正确的。 我们的程序也是如此,我们不能证明我们的代码是绝对正确的，而是做各种</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘三——编程范式</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%B8%89%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Mon, 02 May 2022 22:52:25 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%B8%89%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</guid>
      <description>编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。这些范式会告诉你应该在什么时候采用什么样的代码结构。 目前也只有三个编程范式： 它们分别是结构化编程（structured programming</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘二</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%BA%8C/</link>
      <pubDate>Mon, 02 May 2022 22:52:09 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%BA%8C/</guid>
      <description>对于每个软件系统，我们都可以通过行为和架构两个维度来体现它的实际价值。软件研发人员应该确保自己的系统在这两个维度上的实际价值都能长时间维持在很高的状态 大部分程序员认为这就是他们的全部工作。他们的工作是</description>
    </item>
    
    <item>
      <title>架构整洁之道书摘一</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%B8%80/</link>
      <pubDate>Mon, 02 May 2022 22:51:57 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B9%A6%E6%91%98%E4%B8%80/</guid>
      <description>架构是什么 按照Bob大叔的说法，所谓架构就是“用最小的人力成本来满足构建和维护系统需求”的设计行为。 所谓软件架构，就是你希望在项目一开始就能做对，但是却不一定能够做得对的决策的集合。 从人力成本的角度来</description>
    </item>
    
    <item>
      <title>mysql中的查询缓存</title>
      <link>https://dccmmtop.github.io/posts/mysql%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</link>
      <pubDate>Sun, 24 Apr 2022 22:56:45 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/mysql%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</guid>
      <description>当查询命中缓存时，立即返回结果。跳过了解析 优化和执行阶段 什么时候不会被缓存 查询涉及的相关表数据发生变化时 查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失</description>
    </item>
    
    <item>
      <title>基准测试</title>
      <link>https://dccmmtop.github.io/posts/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:02 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>基准测试 http_load 可以通过一个输入文件提供多个 URL，Hpttp_load 在这些 URL 中随机选择进行测试。 也可以定制 axtp_1oad，使其按照时间比率进行测试，而不仅仅是测试最大请求处理 下面通过一个简单的例子来</description>
    </item>
    
    <item>
      <title>你好!陌生人</title>
      <link>https://dccmmtop.github.io/about/</link>
      <pubDate>Wed, 13 Apr 2022 23:42:17 +0800</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/about/</guid>
      <description>+++ hidden = true +++ 你要克服懒惰 你要克服游手好闲 你要克服漫长的白日梦 你要克服一蹴而就的妄想 你要克服自以为是浅薄的幽默感 你要独立生长在这世上 不寻找不依靠 因为冷漠寡情的人孤独一生 你要坚强,振作,自立 不能软弱,逃避,</description>
    </item>
    
    <item>
      <title>mysql中的字符集</title>
      <link>https://dccmmtop.github.io/posts/mysql%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86/</link>
      <pubDate>Wed, 13 Apr 2022 00:22:41 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/mysql%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86/</guid>
      <description>什么是字符集，什么是排序规则 字符集是只从二进制编码到某类字符符号的映射，该字符集的排序规则简称校对， 如 ASCII码，一个字节就可以表示一个英文字母，参照ASCII码表 为什么需要字符集 因为人类无法直接理</description>
    </item>
    
    <item>
      <title>最长无重复子串</title>
      <link>https://dccmmtop.github.io/posts/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Fri, 08 Apr 2022 00:04:33 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</guid>
      <description>第一种 设置一个滑动窗口，左下标记 l， 右下标记r r 向右移动，记录每个字符的最后一次出现的位置 m 如果当前字符在 m 中存在,并且重复字符出现的位置在l右侧,让l移动到重复字符的下一个位置,跳过重复的字符 r每次</description>
    </item>
    
    <item>
      <title>MySQL外键约束</title>
      <link>https://dccmmtop.github.io/posts/mysql%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Wed, 06 Apr 2022 23:09:21 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/mysql%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F/</guid>
      <description>InnoDB 是MySQL中唯一支持外键约束的内置引擎 缺点 多一次查询 在每次修改数据时，都要在另外一张表执行一次查询操作，如果外键列的选择性很低，会导致存在一个很大但是选择性很低的索引。 比如在一个很大的users表</description>
    </item>
    
    <item>
      <title>异步任务中的错误传递</title>
      <link>https://dccmmtop.github.io/posts/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92/</link>
      <pubDate>Mon, 21 Feb 2022 19:43:14 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92/</guid>
      <description>并发编程下，如何将goroutine中发生的错误传递给其他程序，从而进行优雅的处理呢， 一种解决方案是,将异步任务中产生的错误写入通道中，在另一个程序中读取该通道，从而实现通信，二次处理错误信息 例子 package main</description>
    </item>
    
    <item>
      <title>通道流水线工作模式</title>
      <link>https://dccmmtop.github.io/posts/%E9%80%9A%E9%81%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 21 Feb 2022 19:32:54 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E9%80%9A%E9%81%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</guid>
      <description>一个通道的输出，作为下一个通道的输入，连绵不绝 下面实现了加法 乘法的流水线 // 流水线通道 package main import &amp;#34;fmt&amp;#34; func main() { done := make(chan interface{}) defer close(done) // 数据源 numStream := generate(done, 1, 2, 3, 4, 5) // 乘法 加法 乘法 pipeline := multi(done, add(done, multi(done, numStream, 2), 1), 2) for num := range pipeline { fmt.Println(num) } } // 接收一个中止信</description>
    </item>
    
    <item>
      <title>防止goroutine泄露的一般机制</title>
      <link>https://dccmmtop.github.io/posts/%E9%98%B2%E6%AD%A2goroutine%E6%B3%84%E9%9C%B2%E7%9A%84%E4%B8%80%E8%88%AC%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 21 Feb 2022 19:23:11 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E9%98%B2%E6%AD%A2goroutine%E6%B3%84%E9%9C%B2%E7%9A%84%E4%B8%80%E8%88%AC%E6%9C%BA%E5%88%B6/</guid>
      <description>goroutine 泄露 当 goroutine 被永远阻塞，或者只有主 goroutine 终止时，子 goroutine 才会终止， 即子goroutine 没有自行终止的时机 goroutine 便无法释放其所占的内存空间 一般解决方案: 由父goroutine告知子goroutine终止时机 准则: 父</description>
    </item>
    
    <item>
      <title>select用法示例</title>
      <link>https://dccmmtop.github.io/posts/select%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 21 Feb 2022 19:06:18 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/select%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</guid>
      <description>Go中的select和channel配合使用，通过select可以监听多个channel的I/O读写事件，当 IO操作发生时，触发相应的动作。 基本使用 // 常规示例 func example() { done := make(chan interface{}) // 一段时间后发送关闭信号 go func()</description>
    </item>
    
    <item>
      <title>Linux搭建samba服务</title>
      <link>https://dccmmtop.github.io/posts/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Wed, 19 Jan 2022 11:27:26 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/</guid>
      <description>安装 samba yum install samba 修改配置文件 修改配置文件 vim /etc/samba/smb.conf 添加要共享的目录 [opt] # 被共享目录的别名 path = /home/dccmmtop/opt # 要共享的目录 browseable = yes writable = yes # 可以写入 valid users = dccmmtop # 用户，该用户要有目录的权限 create mode=0777 directory mode=0777 force create mode=0777 force directory mode=0777 添加用户 将用户 dccmmtop 设置为可以</description>
    </item>
    
    <item>
      <title>构建docker环境开发Rails</title>
      <link>https://dccmmtop.github.io/posts/%E6%9E%84%E5%BB%BAdocker%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91rails/</link>
      <pubDate>Thu, 13 Jan 2022 09:05:07 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%9E%84%E5%BB%BAdocker%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91rails/</guid>
      <description>初始化项目 新建 myapp 目录，在下面添加 Dockerfile 文件，如下: Dockerfile FROM ruby:2.5 RUN apt-get update -qq &amp;amp;&amp;amp; apt-get install -y nodejs default-mysql-client ADD . /myapp WORKDIR /myapp RUN bundle install EXPOSE 3000 CMD [&amp;#34;bash&amp;#34;] Gemfile 再新建 Gemfile 文件 source &amp;#39;https://gems.ruby-china.com&amp;#39; # 安装 Rails gem &amp;#39;rails&amp;#39;, &amp;#39;~&amp;gt; 5.1.3&amp;#39; docker-compose.yml version: &amp;#39;3.3&amp;#39; # 使用已经存在的外部网络 networks: default: external: name: dev_network services: web: build: . command: bash -c &amp;#34;rm -f tmp/pids/server.pid &amp;amp;&amp;amp; bundle exec rails s</description>
    </item>
    
    <item>
      <title>Go池</title>
      <link>https://dccmmtop.github.io/posts/go%E6%B1%A0/</link>
      <pubDate>Wed, 15 Dec 2021 19:56:44 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E6%B1%A0/</guid>
      <description>为什么需要池 用来约束创建和复用昂贵的场景，比如数据库连接 Go是怎么实现的池 通过 sync.Pool 包实现，并发安全 怎么使用 Get 方法，首先检查池中是否有可用的实例返回给调用者,如果没有，调用New 方法创建新的实例,并返回 使</description>
    </item>
    
    <item>
      <title>Go单元测试</title>
      <link>https://dccmmtop.github.io/posts/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 23 Nov 2021 23:21:17 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>概念 测试是编程工作中非常重要的一环，但很多人却忽视了这一点，又或者只是把测试看作是一种可有可无的补充手段。Go语言提供了一些基本的测试功能，这些功能初看上去可能会显得非常原始，但正如将要介绍的那样，这</description>
    </item>
    
    <item>
      <title>Go写入json</title>
      <link>https://dccmmtop.github.io/posts/go%E5%86%99%E5%85%A5json/</link>
      <pubDate>Thu, 18 Nov 2021 23:08:29 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E5%86%99%E5%85%A5json/</guid>
      <description>这个封装程序使用的结构和之前分析JSON时使用的结构是相同的。 程序首先会创建一些结构，然后通过调用MarshalIndent函数将结构封装为由字节切片组成的JSON数据 最后，程序会将封装所得的JSON</description>
    </item>
    
    <item>
      <title>Go解析json文件</title>
      <link>https://dccmmtop.github.io/posts/go%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 18 Nov 2021 22:40:07 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6/</guid>
      <description>可以使用Unmarshal函数来解封JSON，还可以使用Decoder手动地将JSON数据解码到结构里面，以此来处理流式的JSON数据， 流程如下 要解析的json文件 { &amp;#34;id&amp;#34;: 1, &amp;#34;content&amp;#34;: &amp;#34;Hello world!&amp;#34;, &amp;#34;author&amp;#34;:{ &amp;#34;id&amp;#34;:2, &amp;#34;name&amp;#34;: &amp;#34;Sau Sheong&amp;#34; }, &amp;#34;comments&amp;#34;: [ { &amp;#34;id&amp;#34;: 3, &amp;#34;content&amp;#34;:</description>
    </item>
    
    <item>
      <title>gorm包使用</title>
      <link>https://dccmmtop.github.io/posts/gorm%E5%8C%85%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 16 Nov 2021 23:14:23 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/gorm%E5%8C%85%E4%BD%BF%E7%94%A8/</guid>
      <description>自动迁移 因为Gorm可以通过自动数据迁移特性来创建所需的数据库表，并在用户修改相应的结构时自动对数据库表进行更新， 当我们运行这个程序时，程序所需的数据库表就会自动生成 负责执行数据迁移操作的AutoMi</description>
    </item>
    
    <item>
      <title>sqlx包的使用</title>
      <link>https://dccmmtop.github.io/posts/sqlx%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 16 Nov 2021 22:07:23 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/sqlx%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>sqlx是一个第三方库，它为database/sql包提供了一系列非常有用的扩展功能。 因为sqlx和database/sql包使用的是相同的接口，所以sqlx能够很好地兼容使用database/sql</description>
    </item>
    
    <item>
      <title>Go与SQL</title>
      <link>https://dccmmtop.github.io/posts/go%E4%B8%8Esql/</link>
      <pubDate>Sat, 13 Nov 2021 22:21:13 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E4%B8%8Esql/</guid>
      <description>连接数据库 sq1.DB结构是一个数据库句柄（handle），它代表的是一个包含了零个或任意多个数据库连接的连接池（pool），这个连接池由sql包管理。程序可以通过调用Open函数，并将相应的数据库驱</description>
    </item>
    
    <item>
      <title>SQL优化</title>
      <link>https://dccmmtop.github.io/posts/sql%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 12 Nov 2021 08:57:15 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/sql%E4%BC%98%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>MySQL 和 Redis 的数据一致性问题</title>
      <link>https://dccmmtop.github.io/posts/mysql%E5%92%8Credis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 11 Nov 2021 20:29:30 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/mysql%E5%92%8Credis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</guid>
      <description>什么是数据的一致性 “数据一致”一般指的是：缓存中有数据，缓存的数据值 = 数据库中的值。 但根据缓存中是有数据为依据，则”一致“可以包含两种情况： 缓存中有数据，缓存的数据值 = 数据库中的值（需均为最新值，本文</description>
    </item>
    
    <item>
      <title>ruby分布式锁</title>
      <link>https://dccmmtop.github.io/posts/ruby%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Thu, 11 Nov 2021 20:24:42 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ruby%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>#ruby的分布式锁实现，基于redis class Redlock DefaultRetryCount=3 DefaultRetryDelay=200 ClockDriftFactor = 0.01 UnlockScript=&amp;#39; if redis.call(&amp;#34;get&amp;#34;,KEYS[1]) == ARGV[1] then return redis.call(&amp;#34;del&amp;#34;,KEYS[1]) else return 0 end&amp;#39; def initialize(*server_urls) @servers = [] server_urls.each{|url| @servers &amp;lt;&amp;lt; Redis.new(:url =&amp;gt; url) } @quorum = server_urls.length / 2 + 1 @retry_count = DefaultRetryCount @retry_delay = DefaultRetryDelay @urandom = File.new(&amp;#34;/dev/urandom&amp;#34;) end def set_retry(count,delay) @retry_count = count @retry_delay = delay end def lock_instance(redis,resource,val,ttl) begin return redis.client.call([:set,resource,val,:nx,:px,ttl]) rescue return false end end def unlock_instance(redis,resource,val) begin redis.client.call([:eval,UnlockScript,1,resource,val]) rescue # Nothing to do, unlocking is just a</description>
    </item>
    
    <item>
      <title>Go读写CSV</title>
      <link>https://dccmmtop.github.io/posts/go%E8%AF%BB%E5%86%99csv/</link>
      <pubDate>Tue, 09 Nov 2021 22:47:15 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E8%AF%BB%E5%86%99csv/</guid>
      <description>对Go语言来说，CSV文件可以通过encoding/csv包进行操作，下面通过这个包来读写CSV文件。 由于程序在接下来的代码中立即就要对写入的posts.csv文件进行读取，而刚刚写入的数据有可能还滞</description>
    </item>
    
    <item>
      <title>幂等设计</title>
      <link>https://dccmmtop.github.io/posts/%E5%B9%82%E7%AD%89%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 09 Nov 2021 21:52:29 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%B9%82%E7%AD%89%E8%AE%BE%E8%AE%A1/</guid>
      <description>概念 幂等这个概念，是一个数学上的概念，即：f……(f(f(x))) = f(x)。用在计算机领域，指的是系统里的接口或方法对外的一种承诺，使用相同参数对同一资源重复调用某个接口或方法的结果与调用一次的结果</description>
    </item>
    
    <item>
      <title>日志切割logrotate原理和配置</title>
      <link>https://dccmmtop.github.io/posts/%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2logrotate%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 08 Nov 2021 22:25:00 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2logrotate%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/</guid>
      <description>logrotate 在很多 Linux 发行版上都是默认安装的。系统会定时运行 logrotate，一般是每天一次。系统是这么实现按天执行的。crontab 会每天定时执行 /etc/cron.daily 目录下的脚本，而这个目录下有个文件叫 logrotate。在 centos</description>
    </item>
    
    <item>
      <title>Go模板之上下文感知</title>
      <link>https://dccmmtop.github.io/posts/go%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%84%9F%E7%9F%A5/</link>
      <pubDate>Mon, 08 Nov 2021 21:32:35 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%84%9F%E7%9F%A5/</guid>
      <description>上下文感知 Go语言的模板引擎可以根据内容所处的上下文改变其显示. 上下文感知的一个显而易见的用途就是对被显示的内容实施正确的转义（escape）：这意味着，如果模板显示的是HTML格式的内容，那么模板将</description>
    </item>
    
    <item>
      <title>Go模板之动作</title>
      <link>https://dccmmtop.github.io/posts/go%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%8A%A8%E4%BD%9C/</link>
      <pubDate>Tue, 02 Nov 2021 22:44:33 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%8A%A8%E4%BD%9C/</guid>
      <description>Go的模板动作就是嵌入模板的命令 条件动作 {{ if arg }} some content {{ else }} other content {{ end }} 迭代动作 迭代动作可以对数组，切片，映射，或者通道进行迭代, 在迭代循环内部， 点(.) 会被设置正在当前迭代内容 设置动作 设置动作允许为指定</description>
    </item>
    
    <item>
      <title>Go的模板引擎</title>
      <link>https://dccmmtop.github.io/posts/go%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 Nov 2021 22:51:35 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</guid>
      <description>Go的模板都是文本文档（其中Web应用的模板通常都是HTML），它们都嵌入了一些称为动作（action）的指令。从模板引擎的角度来说，模板就是嵌入了动作的文本（这些文本通常包含在模板文件里面），而模板</description>
    </item>
    
    <item>
      <title>利用cookie实现闪现消息</title>
      <link>https://dccmmtop.github.io/posts/%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%8E%B0%E6%B6%88%E6%81%AF/</link>
      <pubDate>Thu, 28 Oct 2021 23:20:50 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E9%97%AA%E7%8E%B0%E6%B6%88%E6%81%AF/</guid>
      <description>为了向用户报告某个动作的执行情况，应用程序有时候会向用户展示一条简短的通知消息， 比如说，如果一个用户尝试在论坛上发表一篇帖子，但是这篇帖子因为某种原因而发表失败了，那么论坛应该向这个用户展示一条帖子发</description>
    </item>
    
    <item>
      <title>解析请求头和请求体</title>
      <link>https://dccmmtop.github.io/posts/%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E8%AF%B7%E6%B1%82%E4%BD%93/</link>
      <pubDate>Thu, 28 Oct 2021 00:19:44 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E8%AF%B7%E6%B1%82%E4%BD%93/</guid>
      <description>解析请求头 // 解析请求头 func headers(w http.ResponseWriter, request *http.Request) { // 获取所欲请求头，Header 是个 map, key 是字符串，value 是字符串切片 headers := request.Header fmt.Printf(&amp;#34;所有请求头headers: %v\n&amp;#34;, headers) // 获取单个请求头,返回的是字</description>
    </item>
    
    <item>
      <title>为什么把某些参数放在请求头中</title>
      <link>https://dccmmtop.github.io/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%9F%90%E4%BA%9B%E5%8F%82%E6%95%B0%E6%94%BE%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD/</link>
      <pubDate>Wed, 27 Oct 2021 22:12:48 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A%E6%9F%90%E4%BA%9B%E5%8F%82%E6%95%B0%E6%94%BE%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD/</guid>
      <description>在HTTP协议中，首部和请求体是分开传输的，将一些认证信息参数放在请求头中，服务端先解析请求头，如果认证不通过，可以直接返回认证失败，不用再传输请求体，从而提高服务器的性能。 下面做实验验证,实验思路：</description>
    </item>
    
    <item>
      <title>Cookie操作</title>
      <link>https://dccmmtop.github.io/posts/cookie%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 26 Oct 2021 23:32:10 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/cookie%E6%93%8D%E4%BD%9C/</guid>
      <description>将 cookie 发送给至客户端 Cookie结构的string方法可以返回一个经过序列化处理的cookie，其中Set-Cookie响应首部的值就是由这些序列化之后的cookie组成的。 package main import &amp;#34;net/http&amp;#34; func main(){ server := http.Server{ Addr: &amp;#34;127.0.0.1:8080&amp;#34;, } http.HandleFunc(&amp;#34;/setCookie&amp;#34;,setCookie) server.ListenAndServe()</description>
    </item>
    
    <item>
      <title>Cookie概览</title>
      <link>https://dccmmtop.github.io/posts/cookie%E6%A6%82%E8%A7%88/</link>
      <pubDate>Tue, 26 Oct 2021 23:28:06 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/cookie%E6%A6%82%E8%A7%88/</guid>
      <description>会话 cookie 与持久 cookie 没有设置Expires字段的cookie通常称为会话cookie或者临时cookie，这种cookie在浏览器关闭的时候就会自动被移除。相对而言，设置了Expires字段的cookie通</description>
    </item>
    
    <item>
      <title>设置响应首部及响应体示例</title>
      <link>https://dccmmtop.github.io/posts/%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8/</link>
      <pubDate>Tue, 26 Oct 2021 22:54:48 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8/</guid>
      <description>返回体 func writeExample(w http.ResponseWriter, request *http.Request) { // 没有手动设置响应类型，会通过检测响应的前 512 个字节自动判断响应类型 // 这里是 Content-Type: text/html; charset=utf-8 str:= `&amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Go Web Programming&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;&amp;lt;hl&amp;gt;Hello World&amp;lt;/hl&amp;gt;&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;` w.Write([]byte(str)) } 设置状态码 func writeHeaderExample(w http.ResponseWriter, request *http.Request) { // 设置HTTP 状态码, WriteHeader 方法名有误导，只能设置状态码，而不是</description>
    </item>
    
    <item>
      <title>生成证书及服务端私钥</title>
      <link>https://dccmmtop.github.io/posts/%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A7%81%E9%92%A5/</link>
      <pubDate>Mon, 25 Oct 2021 22:02:11 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A7%81%E9%92%A5/</guid>
      <description>package main import ( &amp;#34;crypto/rand&amp;#34; &amp;#34;crypto/rsa&amp;#34; &amp;#34;crypto/x509&amp;#34; &amp;#34;crypto/x509/pkix&amp;#34; &amp;#34;encoding/pem&amp;#34; &amp;#34;math/big&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; ) func main(){ max := new(big.Int).Lsh(big.NewInt(1), 128) serialNumber, _ := rand.Int(rand.Reader,max) subject := pkix.Name{ Organization: []string {&amp;#34;YX&amp;#34;}, OrganizationalUnit: []string {&amp;#34;YX&amp;#34;}, CommonName: &amp;#34;DC&amp;#34;, } template := x509.Certificate{ SerialNumber: serialNumber, Subject: subject, NotBefore: time.Now(), NotAfter: time.Now().Add(365 * 24 * time.Hour), KeyUsage: x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature, ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth}, IPAddresses: []net.IP{net.ParseIP(&amp;#34;127.0.0.1&amp;#34;)}, } pk, _ := rsa.GenerateKey(rand.Reader,2048) derBytes , _ := x509.CreateCertificate(rand.Reader, &amp;amp;template, &amp;amp;template, &amp;amp;pk.PublicKey, pk) cerOut, _ := os.Create(&amp;#34;cert.pem&amp;#34;) pem.Encode(cerOut, &amp;amp;pem.Block{Type: &amp;#34;CERTIFICATE&amp;#34;, Bytes: derBytes}) cerOut.Close() keyOut , _ := os.Create(&amp;#34;key.pem&amp;#34;) pem.Encode(keyOut, &amp;amp;pem.Block{Type: &amp;#34;RAS PRIVATE KEY&amp;#34;, Bytes: x509.MarshalPKCS1PrivateKey(pk)}) keyOut.Close() }</description>
    </item>
    
    <item>
      <title>Linux_nobody用户</title>
      <link>https://dccmmtop.github.io/posts/linux_nobody%E7%94%A8%E6%88%B7/</link>
      <pubDate>Thu, 21 Oct 2021 17:30:36 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/linux_nobody%E7%94%A8%E6%88%B7/</guid>
      <description>nobody在linux中是一个不能登陆的帐号，一些服务进程如apache，aquid等都采用一些特殊的帐号来运行，比如nobody,news,games等等，这是就可以防止程序本身有安全问题的时候，</description>
    </item>
    
    <item>
      <title>ElasticSearch认知</title>
      <link>https://dccmmtop.github.io/posts/elasticsearch%E8%AE%A4%E7%9F%A5/</link>
      <pubDate>Mon, 18 Oct 2021 23:23:43 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/elasticsearch%E8%AE%A4%E7%9F%A5/</guid>
      <description>概览 为了理解Elasticsearch中数据是如何组织的，从以下两个角度来观察 逻辑设计 搜索应用所要注意的。用于索引和搜索的基本单位是文档，可以将其认为 文档以类型来分组，类型包含若干文档， 类似表格包含若</description>
    </item>
    
    <item>
      <title>Mongo创建文档</title>
      <link>https://dccmmtop.github.io/posts/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sun, 05 Sep 2021 17:46:38 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3/</guid>
      <description>插入并保存文档 db.foo.insert({&amp;#34;bar&amp;#34;: &amp;#34;baz&amp;#34;}) 这个操作会给文档自动增加一个&amp;quot;_id&amp;quot;键（要是原来没有的话），然后将其保存到MongoDB中。 批量插入 如果要向集合中插入多个文档，使用批量插入会快一些。使用批量插</description>
    </item>
    
    <item>
      <title>Mongo_Shell基础操作</title>
      <link>https://dccmmtop.github.io/posts/mongo_shell%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 05 Sep 2021 17:36:12 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/mongo_shell%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
      <description>运行shell MongoDB自带JavaScript shell，可在shell中使用命令行与MongoDB实例交互。 shell是一个功能完备的JavaScript解释器，可运行任意JavaScript</description>
    </item>
    
    <item>
      <title>MongoDB基础</title>
      <link>https://dccmmtop.github.io/posts/mongodb%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 05 Sep 2021 16:47:25 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/mongodb%E5%9F%BA%E7%A1%80/</guid>
      <description>文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。 类似地，集合（collection）可以看作是一个拥有动态模式（dynamic schema）的表。 MongoD</description>
    </item>
    
    <item>
      <title>go_mod的使用</title>
      <link>https://dccmmtop.github.io/posts/go_mod%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 18 Aug 2021 16:23:14 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/go_mod%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Go 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。 从</description>
    </item>
    
    <item>
      <title>count(1)与count(x)的区别</title>
      <link>https://dccmmtop.github.io/posts/count1%E4%B8%8Ecountx%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 15 Aug 2021 10:41:01 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/count1%E4%B8%8Ecountx%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>count(1) and count(*) **当表的数据量大些时，对表作分析之后，使用count(1)还要比使用count(*)用时多了！ ** 从执行计划来看，count(1)和count()的效果是一样的。 但是在表做过分析之后，count</description>
    </item>
    
    <item>
      <title>索引</title>
      <link>https://dccmmtop.github.io/posts/%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Thu, 12 Aug 2021 23:13:39 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E7%B4%A2%E5%BC%95/</guid>
      <description>唯一索引 唯一索引是索引具有的一种属性，让索引具备唯一性，确保这张表中，该条索引数据不会重复出现。在每一次insert和update操作时，都会进行索引的唯一性校验，保证该索引的字段组合在表中唯一。 db.containers.createIndex({name: 1},{unique:true,</description>
    </item>
    
    <item>
      <title>开启查询日志</title>
      <link>https://dccmmtop.github.io/posts/%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</link>
      <pubDate>Thu, 12 Aug 2021 23:13:15 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</guid>
      <description>开启查询日志 方法一：执行MongoDB命令 这个命令只能设置单个组件的日志等级，如果想要一次性设置多个组件的日志等级，可以使用下面的方法： 新建 start_log.js， 内容如下 db.adminCommand( { setParameter: 1, logComponentVerbosity: { verbosity: 1, query: { verbosity: 2 },</description>
    </item>
    
    <item>
      <title>获取本机ip地址</title>
      <link>https://dccmmtop.github.io/posts/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Thu, 12 Aug 2021 23:12:27 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%9C%B0%E5%9D%80/</guid>
      <description>require &amp;#34;socket&amp;#34; local_ip = UDPSocket.open {|s| s.connect(&amp;#34;1.1.1.1&amp;#34;, 1);s.addr.last}</description>
    </item>
    
    <item>
      <title>清除sidekiq任务</title>
      <link>https://dccmmtop.github.io/posts/%E6%B8%85%E9%99%A4sidekiq%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Thu, 12 Aug 2021 23:12:03 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%B8%85%E9%99%A4sidekiq%E4%BB%BB%E5%8A%A1/</guid>
      <description>sidekiq清空队列里任务的方式主要有两种，一是使用sidekiq的api，二是直接操作redis 一、使用sidekiq的api清空队列的任务 sidekiq里有提供操作队列的api，首先引入 require&amp;rsquo;sidekiq/api&#39; 获取所</description>
    </item>
    
    <item>
      <title>ruby多层数组排序</title>
      <link>https://dccmmtop.github.io/posts/ruby%E5%A4%9A%E5%B1%82%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 12 Aug 2021 23:10:45 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ruby%E5%A4%9A%E5%B1%82%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</guid>
      <description>例子如下： 用sort_by def order_weight_sort_by(string) string.split(&amp;#34; &amp;#34;).sort_by do |a| sum_a = a.split(&amp;#34;&amp;#34;).inject(0) { |mem, var| mem += var.to_i } first_number = a[0].to_i [a.size, sum_a, first_number] end.join(&amp;#34; &amp;#34;) end string = &amp;ldquo;56 65 74 100 99 68 86 980 90&amp;rdquo; p order_weight_sort_by(string ) 结果是&amp;quot;90 56 65 74 68 86 99 100 980&amp;quot; 上面的方法是先将字符串变成一个由数字字符串组成的数组。然后</description>
    </item>
    
    <item>
      <title>rails验证码</title>
      <link>https://dccmmtop.github.io/posts/rails%E9%AA%8C%E8%AF%81%E7%A0%81/</link>
      <pubDate>Thu, 12 Aug 2021 23:08:20 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails%E9%AA%8C%E8%AF%81%E7%A0%81/</guid>
      <description>rails验证码 1.安装包 gem &amp;#39;rucaptcha&amp;#39; gem &amp;#39;dalli&amp;#39; 2.配置路由 （最新版本的不用配置路由） mount RuCaptcha::Engine =&amp;gt; &amp;#34;/rucaptcha&amp;#34; 3.controller部分 def create @user = User.new(user_params) if verify_rucaptcha?(@user)&amp;amp;&amp;amp;@user.save ...... 4.view部分 &amp;lt;div class=&amp;#34;form-group &amp;#34;&amp;gt; &amp;lt;%= rucaptcha_input_tag( class:&amp;#39;form-control rucaptcha-text&amp;#39;) %&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; class=&amp;#39;rucaptcha-image-box&amp;#39;&amp;gt;&amp;lt;%= rucaptcha_image_tag(class:&amp;#39;rucaptcha-image&amp;#39;, alt: &amp;#39;Captcha&amp;#39;) %&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; 5.实现点击图片刷新验证码 #</description>
    </item>
    
    <item>
      <title>参数路由与路由冲突解决与筛选路由</title>
      <link>https://dccmmtop.github.io/posts/%E5%8F%82%E6%95%B0%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E7%AD%9B%E9%80%89%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Thu, 12 Aug 2021 22:53:06 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%8F%82%E6%95%B0%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E7%AD%9B%E9%80%89%E8%B7%AF%E7%94%B1/</guid>
      <description>有时候我需要写一个页面能向show edit 那样可以接受参数的路由,弄了好久不知道怎样解决,今天恍然大悟 我们执行 rake routes 就会看到如下 wechat_nodes GET /wechat/nodes(.:format) wechat/nodes#index POST /wechat/nodes(.:format) wechat/nodes#create new_wechat_node GET /wechat/nodes/new(.:format) wechat/nodes#new edit_wechat_node GET /wechat/nodes/:id/edit(.:format) wechat/nodes#edit wechat_node GET /wechat/nodes/:id(.:format) wechat/nodes#show PATCH /wechat/nodes/:id(.:format) wechat/nodes#update PUT /wechat/nodes/:id(.:format) wechat/nodes#update DELETE /wechat/nodes/:id(.:format) wechat/nodes#destroy 这是使用resource</description>
    </item>
    
    <item>
      <title>存储过程添加列</title>
      <link>https://dccmmtop.github.io/posts/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%88%97/</link>
      <pubDate>Tue, 10 Aug 2021 18:19:22 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%88%97/</guid>
      <description>存储过程添加列 create procedure add_col( in model_name text, in col_name text, in col_info text, out result text ) begin if not exists( select * from information_schema.COLUMNS where TABLE_NAME = model_name and COLUMN_NAME = col_name) then set @ddl=CONCAT(&amp;#39;alter table &amp;#39;, model_name, &amp;#39; add column &amp;#39;, col_name, col_info); prepare stmt from @ddl; execute stmt; set result = &amp;#39;success&amp;#39;; else set result = &amp;#39;exists&amp;#39;; end if; end; set @result = &amp;#39;&amp;#39;; call add_col(&amp;#39;zyb_employee&amp;#39;,&amp;#39;senior_1 &amp;#39;,&amp;#39;tinyint(1) NULL DEFAULT 0 COMMENT &amp;#34;是否是高级用户，0 不是 1 是&amp;#</description>
    </item>
    
    <item>
      <title>MySQL隔离级别</title>
      <link>https://dccmmtop.github.io/posts/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Tue, 10 Aug 2021 18:17:48 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>MySQL隔离级别 隔离级别是针对数据库 ACID 中的I(隔离性)来说的 原子性 一致性 隔离性 持久性 隔离性 通常来说，一个事务所做的修改，在最终提交以前，对其他事务是不可见的，为什么是 “通常来说”，因为这种特性和隔离</description>
    </item>
    
    <item>
      <title>mysql慢日志</title>
      <link>https://dccmmtop.github.io/posts/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 10 Aug 2021 18:16:04 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>开启慢日志 在 MySQL 中，慢查询日志默认为OFF状态，通过如下命令进行查看： show variables like &amp;quot;slow_query_log&amp;quot;; 通过如下命令进行设置为 ON 状态： set global slow_query_log = &amp;quot;ON&amp;quot;; 日志存储位置 其中slow_query_log_file属性，表示慢查询日志存储位置，</description>
    </item>
    
    <item>
      <title>Ubuntu 安装 mysql 及配置远程访问</title>
      <link>https://dccmmtop.github.io/posts/ubuntu%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</link>
      <pubDate>Tue, 10 Aug 2021 18:12:14 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ubuntu%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</guid>
      <description>安装 sudo apt-get install mysql-server mysql-client 配置远程可连接 你想myuser使用mypassword（密码）从任何主机连接到mysql服务器的话。 mysql&amp;gt;GRANT ALL PRIVILEGES ON *.* TO &amp;#39;用户名&amp;#39;@&amp;#39;%&amp;#39;IDENTIFIED BY &amp;</description>
    </item>
    
    <item>
      <title>分析nginx日志</title>
      <link>https://dccmmtop.github.io/posts/%E5%88%86%E6%9E%90nginx%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 10 Aug 2021 18:10:24 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%88%86%E6%9E%90nginx%E6%97%A5%E5%BF%97/</guid>
      <description>GoAccess的多种展示方式 goaccess有多种数据可视化的方式,分别为: 命令行输出格式化数据 利用access.log生成静态的可视化数据 生成实时可视化数据 注意，如果是编译安装且选择了 –enabl</description>
    </item>
    
    <item>
      <title>arch添加rc.local 实现开机自启</title>
      <link>https://dccmmtop.github.io/posts/arch%E6%B7%BB%E5%8A%A0rc.local%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</link>
      <pubDate>Tue, 10 Aug 2021 17:55:56 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/arch%E6%B7%BB%E5%8A%A0rc.local%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</guid>
      <description>现在有需求，想要开机就运行一些东西，方法有两个，一个是桌面级的启动，一个是系统级的启动 桌面级别，就是进入桌面后，自动打开一些软件 系统级别就是再没有进入桌面就运行一些东西。 先谈桌面级的，比如 gnome，</description>
    </item>
    
    <item>
      <title>同时连接内网和外网</title>
      <link>https://dccmmtop.github.io/posts/%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E5%92%8C%E5%A4%96%E7%BD%91/</link>
      <pubDate>Tue, 10 Aug 2021 17:50:41 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E5%92%8C%E5%A4%96%E7%BD%91/</guid>
      <description>笔记本可以同时连接无线和有线，如果可以指定哪些ip使用无线，哪些ip地址可以使用有线， 假设无线连接的是内网， 有线连接的是外网，可以设置静态路由，使访问不同的地址使用不同的网络 首先确定 本机 无线和有线 的网</description>
    </item>
    
    <item>
      <title>git生成公钥</title>
      <link>https://dccmmtop.github.io/posts/git%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5/</link>
      <pubDate>Tue, 10 Aug 2021 17:50:06 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/git%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5/</guid>
      <description>Git配置多个SSH-Key 当有多个git账号时，比如： a. 一个gitee，用于公司内部的工作开发； b. 一个github，用于自己进行一些开发活动； 解决方法 生成一个公司用的SSH-Key $ ssh-keygen -t rsa -C &amp;#39;xxxxx@company.com&amp;#39; -f ~/.ssh/gitee_id_rsa 生</description>
    </item>
    
    <item>
      <title>制作docSet文档</title>
      <link>https://dccmmtop.github.io/posts/%E5%88%B6%E4%BD%9Cdocset%E6%96%87%E6%A1%A3/</link>
      <pubDate>Tue, 10 Aug 2021 17:33:16 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%88%B6%E4%BD%9Cdocset%E6%96%87%E6%A1%A3/</guid>
      <description>docSet 文档可用于 zeal dash 软件中。 zeal 在win 下 和 Linux 均有可用版本 dash 则只在 Mac 可用 制作 dcocSet 文档主要分 3 步 镜像文档网站 做镜像网站就是把整个网站爬下来，并且把 css 和 js 图片等静态资源文件转换成本地的路径， 主要使用工具是 wget 以 vue 中</description>
    </item>
    
    <item>
      <title>忽略改动</title>
      <link>https://dccmmtop.github.io/posts/%E5%BF%BD%E7%95%A5%E6%94%B9%E5%8A%A8/</link>
      <pubDate>Tue, 10 Aug 2021 17:10:57 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%BF%BD%E7%95%A5%E6%94%B9%E5%8A%A8/</guid>
      <description>git 库中已经有文件被跟踪，如何忽略本地改动后的跟踪 放入到.gitinore 并没有什么用，还是会显示改动，是否要提交，看着很烦 忽略本地文件，且不会对线上库里的文件造成影响，执行此命令: git update-index --assume-unchanged filename 如果想撤销忽</description>
    </item>
    
    <item>
      <title>Linux tmux 安装及配置</title>
      <link>https://dccmmtop.github.io/posts/%E4%BD%BF%E7%94%A8tmux/</link>
      <pubDate>Tue, 10 Aug 2021 11:21:12 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E4%BD%BF%E7%94%A8tmux/</guid>
      <description>为什么要使用tmux? 对我个人而言，tmux 对我最大的吸引力就是 多窗口，以及会话的保持与恢复，我可以很方便的切换窗口，以及快速恢复工作环境 安装 我使用的是源码安装， 下载源码 下载链接 解压 进入到解压目录，执</description>
    </item>
    
    <item>
      <title>修改时区</title>
      <link>https://dccmmtop.github.io/posts/%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/</link>
      <pubDate>Tue, 10 Aug 2021 11:18:51 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/</guid>
      <description>Linux修改时区的正确方法 CentOS和Ubuntu的时区文件是/etc/localtime，但是在CentOS7以后localtime以及变成了一个链接文件 [root@centos7 ~]# ll /etc/localtime lrwxrwxrwx 1 root root 33 Oct 12 11:01 /etc/localtime -&amp;gt; /usr/share/zoneinfo/Asia/Shanghai 如果采用直</description>
    </item>
    
    <item>
      <title>ssh慢</title>
      <link>https://dccmmtop.github.io/posts/ssh%E6%85%A2/</link>
      <pubDate>Tue, 10 Aug 2021 10:48:44 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ssh%E6%85%A2/</guid>
      <description>在目标机器中修改/etc/ssh/sshd_conf文件 将UseDNS 的缺省值由yes修改为no，并重启ssh</description>
    </item>
    
    <item>
      <title>linux批量重命名</title>
      <link>https://dccmmtop.github.io/posts/linux%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/</link>
      <pubDate>Tue, 10 Aug 2021 10:12:57 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/linux%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/</guid>
      <description>通过rename命令批量重命名文件 基本语法 示例 改变文件扩展名 大写改成小写 更改文件名模式 通过rename命令批量重命名文件 基本语法 rename [-n -v -f] &amp;lt;pcre&amp;gt; &amp;lt;files&amp;gt; &amp;lsquo;pcre’是Perl兼容正则表达式，它表示的是</description>
    </item>
    
    <item>
      <title>git 设置和取消代理</title>
      <link>https://dccmmtop.github.io/posts/git%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86/</link>
      <pubDate>Sun, 08 Aug 2021 17:18:35 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/git%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86/</guid>
      <description>设置ss git config --global http.proxy &amp;#39;socks5://127.0.0.1:1080&amp;#39; git config --global https.proxy &amp;#39;socks5://127.0.0.1:1080&amp;#39; 设置代理 git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy</description>
    </item>
    
    <item>
      <title>单向通道</title>
      <link>https://dccmmtop.github.io/posts/%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93/</link>
      <pubDate>Tue, 03 Aug 2021 23:02:05 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93/</guid>
      <description></description>
    </item>
    
    <item>
      <title>变量</title>
      <link>https://dccmmtop.github.io/posts/%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sun, 01 Aug 2021 11:36:29 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%8F%98%E9%87%8F/</guid>
      <description>var 方式 var name type = expiression var name string = &amp;#34;zhangsan&amp;#34; var name = &amp;#34;zhangsan&amp;#34; var name string // 默认值是 &amp;#34;&amp;#34; 变量列表声明 var 方式通常用户和初始化类型不一致的局部变量，或则初始化值不重要的情况 短变量声明 多变量声明 i,j := 0,1 重点 := 代表声明 = 标识赋值 交换值 i,j = j,i 第二次</description>
    </item>
    
    <item>
      <title>数组与切片</title>
      <link>https://dccmmtop.github.io/posts/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</link>
      <pubDate>Thu, 29 Jul 2021 23:11:14 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</guid>
      <description>数组 初始化 指定长度 a := [2]int{1,2} // 指定长度和字面量 不指定长度 a := [...]int{1,2} //不指定长度，有后面的列表来确定其长度 指定总长度，通过索引初始化, 没有初始化的位置使用默认值 a := [3]int{1:1, 2:3} 不指定总长度，通过索引初始化, 最后一个索</description>
    </item>
    
    <item>
      <title>iota 用法</title>
      <link>https://dccmmtop.github.io/posts/iota-%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 29 Jul 2021 22:49:53 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/iota-%E7%94%A8%E6%B3%95/</guid>
      <description>用在常量声明中，初始值为0，一组常量同时声明时，其值逐行增加 类似枚举 const ( c0 = iota //c0 == 0 c1 = iota //c1 == 1 c2 = iota //c2 == 2 ) 简写模式 const ( c0 = iota // c0 == 0 c1 // c1 == 1 c2 // c2 == 2 ) 分开的const 分开的const语句， iota 的</description>
    </item>
    
    <item>
      <title>交叉编译</title>
      <link>https://dccmmtop.github.io/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sun, 25 Jul 2021 10:24:03 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>1.Mac下编译Linux, Windows Linux CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build filename.go Windows CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build filename.go 如: CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o helloworld-windows helloworld.go 2.Linux下编译Mac, Windows Mac CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build filename.go Windows CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build filename.go 3.Windows下编译Mac, Linux Mac SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build filename.go Linux SET CGO_ENABLED=0 SET GOOS=linux</description>
    </item>
    
    <item>
      <title>多行变单行</title>
      <link>https://dccmmtop.github.io/posts/%E5%A4%9A%E8%A1%8C%E5%8F%98%E5%8D%95%E8%A1%8C/</link>
      <pubDate>Sat, 10 Jul 2021 16:58:13 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%A4%9A%E8%A1%8C%E5%8F%98%E5%8D%95%E8%A1%8C/</guid>
      <description>ps -ef | grep nginx | awk -F &#39; &#39; &#39;{print $2}&#39;| xargs</description>
    </item>
    
    <item>
      <title>扩展git功能的一种方式</title>
      <link>https://dccmmtop.github.io/posts/%E6%89%A9%E5%B1%95git%E5%8A%9F%E8%83%BD%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 10 Jun 2021 17:17:09 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E6%89%A9%E5%B1%95git%E5%8A%9F%E8%83%BD%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>有时需要根据自己的工作场合去扩展 git 命令,比如 推送到仓库后自动打开浏览器跳转到发起合并求页面 分支命名比较长其相似度比较大时，自动补全不那么有效率，给每个分支编号，输入指定编号即可切换对应的分支 我最推荐的</description>
    </item>
    
    <item>
      <title>基本类型以及范围</title>
      <link>https://dccmmtop.github.io/posts/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Tue, 13 Apr 2021 23:59:32 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E8%8C%83%E5%9B%B4/</guid>
      <description>基本类型以及范围 选择优化的数据类型 MySQL 支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管 存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。 更小的通常更好。 一般情况下,应该尽</description>
    </item>
    
    <item>
      <title>去除重复行</title>
      <link>https://dccmmtop.github.io/posts/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C/</link>
      <pubDate>Sat, 09 Nov 2019 18:05:59 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C/</guid>
      <description>先sort排序，再去重 :sort //直接排序 :g/^\(.*\)$\n\1$/d //去除重复行 :g/\%(^\1$\n\)\@&amp;lt;=\(.*\)$/d //功能同上，也是去除重复行 :g/\%(^\1\&amp;gt;.*$\n\)\@&amp;lt;=\(\k\+\).*$/d //功能同上，也是去除重复行 使用awk awk &#39;!a[$0]++&#39; file 解析： awk流程是逐行处理的，默认从文件的第一行一直处理到文件最后一行 还</description>
    </item>
    
    <item>
      <title>whenever使用方式</title>
      <link>https://dccmmtop.github.io/posts/whenever%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 31 Oct 2019 22:04:20 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/whenever%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;p&gt;根据项目的进展，我们需要实现后台进行定时读取信息的功能，而最关键的实现部分是周期性功能，根据调研，决定使用whenever来实现这一功能。&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&#34;https://link.jianshu.com?t=https://github.com/javan/whenever&#34;&gt;https://github.com/javan/whenever&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;开发前需要明确的问题&#34;&gt;开发前需要明确的问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;whenever是怎样一种周期性机制？&lt;/li&gt;
&lt;li&gt;whenever能为我们提供什么功能？&lt;/li&gt;
&lt;li&gt;whenever为周期性任务提供了哪些控制方式？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题解决&lt;/p&gt;
&lt;p&gt;whenever周期性机制&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>vim中与系统的粘贴和复制</title>
      <link>https://dccmmtop.github.io/posts/vim%E4%B8%AD%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B2%98%E8%B4%B4%E5%92%8C%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Thu, 31 Oct 2019 22:01:14 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/vim%E4%B8%AD%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B2%98%E8%B4%B4%E5%92%8C%E5%A4%8D%E5%88%B6/</guid>
      <description>&lt;p&gt;以前就遇到过的问题。有如下情景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.假设现在我要将文件a的部分内容复制到文件b中，一般情况，我会用&lt;code&gt;vs&lt;/code&gt;或者&lt;code&gt;sp&lt;/code&gt;命令打开这两个文件然后用&lt;code&gt;y&lt;/code&gt;和&lt;code&gt;p&lt;/code&gt;进行复制粘贴。但是如果分别用vim打开这两个文件就不能完成上述动作。 
2.假设我先在要把vim打开的源代码中的部分内容复制到博客中，一般我会用vim编辑好以后，退出用gedit打开，或者cat一下，再复制到系统剪切板，再粘贴。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天，对于vim这个没办法跟“外界”交流的特性忍够了，决定解决一下。&lt;/p&gt;
&lt;h3 id=&#34;1首先查看vim版本是否支持clipboard&#34;&gt;&lt;strong&gt;1.首先，查看vim版本是否支持clipboard&lt;/strong&gt;&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim --version | grep &amp;#34;clipboard&amp;#34;1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdn.net/20161215215734971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd4aWFvOTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;这里写图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;clipboard 前面有一个小小的减号，说明不支持。&lt;/p&gt;
&lt;h3 id=&#34;2如果不支持的话需要安装图形化界面的vim或者重新编译vim&#34;&gt;&lt;strong&gt;2.如果不支持的话，需要安装图形化界面的vim，或者重新编译vim&lt;/strong&gt;&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get install vim-gnome1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ubuntu中添加服务以及开机自启</title>
      <link>https://dccmmtop.github.io/posts/ubuntu%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</link>
      <pubDate>Sun, 28 Apr 2019 17:59:37 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ubuntu%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</guid>
      <description>自定义脚本 编写自己的需要开启自启的脚本，如下： #!/usr/bin/env ruby `cd /home/mc/code/rails_app/master_crawler_trm &amp;amp;&amp;amp; nohup rake real_time_extract_word &amp;gt; /dev/null 2&amp;amp;&amp;gt;1` 启动脚本 #!/usr/bin/env ruby start = &amp;#34; sudo -u mc /home/mc/bin/real_time_extract_words &amp;#34; stop = &amp;#34;ps -ef | grep real_time_extract_word | grep -v grep | cut -c 9-15 | xargs kill -9&amp;#34; action = ARGV[0] if action == &amp;#39;start&amp;#39; system(start) puts &amp;#34;启动成功&amp;#34; elsif action == &amp;#39;stop&amp;#39; system(stop) puts &amp;#34</description>
    </item>
    
    <item>
      <title>Rails连接多个数据库</title>
      <link>https://dccmmtop.github.io/posts/rails%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Wed, 03 Apr 2019 11:48:31 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>假如已经连接的的数据库名是 word_development, 现在需要添加一个名为 trademark_development 和 trademark_test 的本地数据库 步骤如下: 添加配置信息 在 config/database.yml 添加如下信息 trademark_default: &amp;amp;trademark_default adapter: postgresql encoding: unicode pool: &amp;lt;%= ENV.fetch(&amp;#34;RAILS_MAX_THREADS&amp;#34;) { 5 } %&amp;gt; trademark_development: &amp;lt;&amp;lt;: *trademark_default database: trademark_development # 如果是远程的数据库添加如下信息 #username: username #password: 123456 #host: xxxx #port: xxx trademark_test: &amp;lt;&amp;lt;: *trademark_default database: trademark_test 关</description>
    </item>
    
    <item>
      <title>触发器创建示例</title>
      <link>https://dccmmtop.github.io/posts/%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Sat, 30 Mar 2019 09:15:25 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B/</guid>
      <description>摘抄自 《posrgreSQL 修炼之道 从小工到专家》 触发器（trigger）是一种由事件自动触发执行的特殊的存储过程，这些事件可以是对一个表进行 INSERT,UPDATE,DELETE 等操作 触发器经常用于加强数据库的完整性约束和业务规则上的</description>
    </item>
    
    <item>
      <title>Rails5中的autoload和eager_load</title>
      <link>https://dccmmtop.github.io/posts/rails5%E4%B8%AD%E7%9A%84autoload%E5%92%8Ceager_load/</link>
      <pubDate>Sat, 19 Jan 2019 10:21:48 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails5%E4%B8%AD%E7%9A%84autoload%E5%92%8Ceager_load/</guid>
      <description>翻译并整理： https://collectiveidea.com/blog/archives/2016/07/22/solutions-to-potential-upgrade-problems-in-rails-5 https://blog.bigbinary.com/2016/08/29/rails-5-disables-autoloading-after-booting-the-app-in-production.html autoload和eager_load autoload: 在常量使用之前不会加载，只有当使用一个当前不存在常量时，会在 autoload_paths 寻找，然后加载它，当在给定的目录中找不到这个常量时，就会触发错误。并且 autoload 是非线程安</description>
    </item>
    
    <item>
      <title>ruby中hash的排序</title>
      <link>https://dccmmtop.github.io/posts/ruby%E4%B8%ADhash%E7%9A%84%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 15 Jan 2019 11:45:27 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ruby%E4%B8%ADhash%E7%9A%84%E6%8E%92%E5%BA%8F/</guid>
      <description>翻译自 https://medium.com/@florenceliang/some-notes-about-using-hash-sort-by-in-ruby-f4b3a700fc33 ruby中的sort和sort_by 是两个非常有用的工具，我们可以按照自己的想法排序。比如我们可以按照名字字母表或者名字的长短进行排序。但是ruby文档中却没有过多的说明，因此本文主要说明一下</description>
    </item>
    
    <item>
      <title>vim删除不包含特定字符串的行</title>
      <link>https://dccmmtop.github.io/posts/vim%E5%88%A0%E9%99%A4%E4%B8%8D%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A1%8C/</link>
      <pubDate>Wed, 09 Jan 2019 15:25:29 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/vim%E5%88%A0%E9%99%A4%E4%B8%8D%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A1%8C/</guid>
      <description>:g/xxx/d，删除包含xxx的行 :v/xxx/d，删除不含xxx的行 :%s/xxx//gn，统计xxx个数，n表示只报告匹配的个数而不进行实际的替换。 详见「:help :v」或「help :g」</description>
    </item>
    
    <item>
      <title>用ruby执行系统命令</title>
      <link>https://dccmmtop.github.io/posts/%E7%94%A8ruby%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 03 Jan 2019 09:50:00 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E7%94%A8ruby%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid>
      <description>反引号 返回标准输出 output = `ls` puts &amp;#34;output is #{output}&amp;#34; Result of above code is $ ruby main.rb output is lab.rb 反引号执行系统命令时，会把异常抛给主线程 反引号会从主进程新开一个进程执行命令，如果子进程发生异常，会传递给主进程，如果主进程没有对异常进行处理，主</description>
    </item>
    
    <item>
      <title>xpath用法</title>
      <link>https://dccmmtop.github.io/posts/xpath%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 02 Jan 2019 17:56:48 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/xpath%E7%94%A8%E6%B3%95/</guid>
      <description>整理自https://devhints.io/xpath#prefixes Descendant selectors h1 //h1 div p //div//p ul &amp;gt; li //ul/li ul &amp;gt; li &amp;gt; a //ul/li/a div &amp;gt; * //div/* :root / :root &amp;gt; body /body Attribute selectors #id //*[@id=&amp;quot;id&amp;quot;] .class //*[@class=&amp;quot;class&amp;quot;] …kinda input[type=&amp;quot;submit&amp;quot;] //input[@type=&amp;quot;submit&amp;quot;] a#abc[for=&amp;quot;xyz&amp;quot;] //a[@id=&amp;quot;abc&amp;quot;][@for=&amp;quot;xyz&amp;quot;] a[rel] //a[@rel] a[href^=&#39;/&#39;] //a[starts-with(@href, &#39;/&#39;)] a[href$=&#39;pdf&#39;] //a[ends-with(@href, &#39;.pdf&#39;)] a[href*=&#39;://&#39;] //a[contains(@href, &#39;://&#39;)] a[rel~=&#39;help&#39;] //a[contains(@rel, &#39;help&#39;)] …kinda</description>
    </item>
    
    <item>
      <title>yakuake配置color-theme</title>
      <link>https://dccmmtop.github.io/posts/yakuake%E9%85%8D%E7%BD%AEcolor-theme/</link>
      <pubDate>Fri, 28 Dec 2018 11:31:57 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/yakuake%E9%85%8D%E7%BD%AEcolor-theme/</guid>
      <description>打开管理配置， &amp;ndash;&amp;gt; appearance &amp;ndash;&amp;gt; new 给新的 color theme 命名(gruvbox)，然后点击应用，保存。 打开 .kde/share/apps/konsole/gruvbox.colortheme,清空文件内容 在 manjaro 中， 该文件位于 ~/.local/share/konsole/ 目</description>
    </item>
    
    <item>
      <title>rails发送qq邮件的配置</title>
      <link>https://dccmmtop.github.io/posts/rails%E5%8F%91%E9%80%81qq%E9%82%AE%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 28 Nov 2018 17:26:31 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails%E5%8F%91%E9%80%81qq%E9%82%AE%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>rails 中使用邮件服务是非常方便的，直接加配置文件就可以，参考指南 qq 邮箱正确的配置如下 production.rb / development.rb ActionMailer::Base.delivery_method = :smtp config.action_mailer.perform_deliveries = true config.action_mailer.raise_delivery_errors = true config.action_mailer.default :charset =&amp;gt; &amp;#34;utf-8&amp;#34; ActionMailer::Base.smtp_settings = { :address =&amp;gt; &amp;#39;smtp.qq.com&amp;#39;, :port =&amp;gt; 465, :domain =&amp;gt; &amp;#39;qq.com&amp;#39;, :user_name =&amp;gt; ENV[&amp;#39;qq_mail_address&amp;#39;] # 授权码 :password =&amp;gt; ENV[&amp;#39;qq_mail_address&amp;#39;] :authentication =&amp;gt; &amp;#39;plain&amp;#39;, :ssl =&amp;gt; true, :enable_starttls_auto =&amp;gt; true } 切记，qq 邮箱后台要开启</description>
    </item>
    
    <item>
      <title>postgres系列之用户及权限管理</title>
      <link>https://dccmmtop.github.io/posts/postgres%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%A8%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 25 Nov 2018 22:58:15 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/postgres%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%A8%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>在初始化数据库系统时，有一个预定义的超级用户，这用户的名称与初始化该数据库的操作系统用户名相同，默认是 postgres，在这个超级用户连接数据库，然后创建出更多的用户。 创建用户和角色 创建用户与角色的语</description>
    </item>
    
    <item>
      <title>ruby_heredoc的用法</title>
      <link>https://dccmmtop.github.io/posts/ruby_heredoc%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 22 Nov 2018 09:23:36 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ruby_heredoc%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>整理自ruby-china 基础的用法 def print_heredoc puts &amp;lt;&amp;lt;EOF this is the first line this is the second line EOF end print_heredoc 输出： this is the first line this is the second line 如果你觉得代码太难看（这根本不符合 Ruby 的风格），你可能会这样写： def print_heredoc puts &amp;lt;&amp;lt;EOF this is the first line this is the second line EOF end print_heredoc 你会发现</description>
    </item>
    
    <item>
      <title>rails_多态关联</title>
      <link>https://dccmmtop.github.io/posts/rails_%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94/</link>
      <pubDate>Wed, 21 Nov 2018 15:35:41 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails_%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94/</guid>
      <description>什么是多态关联 假如有三个模型，分别是 用户， 产品， 图片。图片为用户所有，也为产品所有。我们可以创建两个 picture 的模型，如下 rails g modle picture_user user_id:integer name:string url:string rails g modle picture_product product_id:integer name:string url:string class PictureUser &amp;lt; ApplicationRecord belongs_to :user end class PictureProduct &amp;lt; ApplicationRecord belongs_to :product end 这样我们就可以使用user.p</description>
    </item>
    
    <item>
      <title>rails_action_cable使用</title>
      <link>https://dccmmtop.github.io/posts/rails_action_cable%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 18 Nov 2018 17:24:00 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails_action_cable%E4%BD%BF%E7%94%A8/</guid>
      <description>安装 redis gem redis bundle install 修改 cable.yml development: adapter: redis 生成订阅 rails g channel block speak 连接设置 连接是客户端-服务器通信的基础。每当服务器接受一个 WebSocket，就会实例化一个连接对象。所有频道订阅（channel subscription）</description>
    </item>
    
    <item>
      <title>vim脚本插件化</title>
      <link>https://dccmmtop.github.io/posts/vim%E8%84%9A%E6%9C%AC%E6%8F%92%E4%BB%B6%E5%8C%96/</link>
      <pubDate>Sun, 28 Oct 2018 15:48:33 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/vim%E8%84%9A%E6%9C%AC%E6%8F%92%E4%BB%B6%E5%8C%96/</guid>
      <description>日积月累，自己写的 vim 脚本越来越多，大大的方便了日常编写任务，但是这些脚本没有做成插件的形式，导致换一台新机器时，不方便下载使用，下面就介绍一下如何把 自己写的脚本做成一个插件，可以在vimrc中使用Pl</description>
    </item>
    
    <item>
      <title>vim自定义命令</title>
      <link>https://dccmmtop.github.io/posts/vim%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 23 Oct 2018 14:29:42 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/vim%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4/</guid>
      <description>本文章为转载内容，点击查看原文章https://zhuanlan.zhihu.com/p/27389503 使用脚本语言，可以更灵活地定制编辑器以完成复杂的任务。 自定义命令 Vim 编辑器允许定义自己的命令，我</description>
    </item>
    
    <item>
      <title>自动添加序号</title>
      <link>https://dccmmtop.github.io/posts/%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%8F%B7/</link>
      <pubDate>Tue, 23 Oct 2018 12:58:16 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%8F%B7/</guid>
      <description>需求 给一段文字自动添加序号，要求本行的序号可以根据上一行的序号自动增一，若上一行没有序号，则从 1 开始 实现 用 ruby 编写 vim 脚本非常容易实现 &amp;#34; 每行的前面添加序号，根据上一行序号自动递增，若上一行没有序号，则从1</description>
    </item>
    
    <item>
      <title>自定义range对象</title>
      <link>https://dccmmtop.github.io/posts/%E8%87%AA%E5%AE%9A%E4%B9%89range%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 27 Sep 2018 09:10:50 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E8%87%AA%E5%AE%9A%E4%B9%89range%E5%AF%B9%E8%B1%A1/</guid>
      <description>ruby 中有个 range 对象，可以自动推测范围内的数据，比如： (1..100).each do |i| puts i end 会输出 1 到 100 内的所有数字 自定义 如果我们有一个自定义的对象，假如名字为Ym class Ym attr_accessor :year, :month def initialize @year, @month = year, month end end 若是想在Ym上使用((Ym.new(20</description>
    </item>
    
    <item>
      <title>vim中的正则表达式</title>
      <link>https://dccmmtop.github.io/posts/vim%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 21 Sep 2018 14:28:51 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/vim%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>首先，在哪些情况下会用到正则表达式？ 使用正则表达式的命令最常见的就是 / 和 ? 命令。其格式如下： /正则表达式 ?正则表达式 另一个很有用的命令就是 :s（替换）命令，将第一个//之间的正则表达式替换成第二个//</description>
    </item>
    
    <item>
      <title>rack-cors解决Ajax跨域问题-CORS</title>
      <link>https://dccmmtop.github.io/posts/rack-cors%E8%A7%A3%E5%86%B3ajax%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-cors/</link>
      <pubDate>Wed, 19 Sep 2018 09:25:49 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rack-cors%E8%A7%A3%E5%86%B3ajax%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-cors/</guid>
      <description>什么是跨域 理解跨域首先必须要了解同源策略。同源策略是浏览器上为安全性考虑实施的非常重要的安全策略。 那么什么是同源？我们知道，URL 由协议、域名、端口和路径组成，如果两个 URL 的协议、域名和端口相同，则表示</description>
    </item>
    
    <item>
      <title>用ruby编写vim脚本</title>
      <link>https://dccmmtop.github.io/posts/%E7%94%A8ruby%E7%BC%96%E5%86%99vim%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Thu, 30 Aug 2018 17:36:12 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E7%94%A8ruby%E7%BC%96%E5%86%99vim%E8%84%9A%E6%9C%AC/</guid>
      <description>在开始编写插件之前，你需要确认 Vim 是否支持 Ruby，通过以下命令来判别： $ vim --version | grep +ruby 如果输出为空，则表示你当前的 vim 不支持 Ruby，需要重新编译一下，并启用对 Ruby 的支持。 如果没有问题那就开始吧！ 下面的示例是</description>
    </item>
    
    <item>
      <title>rails重写字段</title>
      <link>https://dccmmtop.github.io/posts/rails%E9%87%8D%E5%86%99%E5%AD%97%E6%AE%B5/</link>
      <pubDate>Mon, 20 Aug 2018 18:09:07 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails%E9%87%8D%E5%86%99%E5%AD%97%E6%AE%B5/</guid>
      <description>在 rails 中,model 的属性是默认的可读可写的，有时我们需要重写某个字段的访问器。当查询某个字段的值时，需要进行其他操作； 如： 当查询recommand_code的值时，若存在，则返回，若不存在则创建一个包</description>
    </item>
    
    <item>
      <title>SSH隧道</title>
      <link>https://dccmmtop.github.io/posts/ssh%E9%9A%A7%E9%81%93/</link>
      <pubDate>Sun, 19 Aug 2018 17:04:28 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ssh%E9%9A%A7%E9%81%93/</guid>
      <description>在开发微信公众号或小程序的时候，由于微信平台规则的限制，部分接口需要通过线上域名才能正常访问。但我们一般都会在本地开发，因为这能快速的看到源码修改后的运行结果。但当涉及到需要调用微信接口时，由于不和你</description>
    </item>
    
    <item>
      <title>rails-自关联</title>
      <link>https://dccmmtop.github.io/posts/rails-%E8%87%AA%E5%85%B3%E8%81%94/</link>
      <pubDate>Wed, 15 Aug 2018 12:22:06 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails-%E8%87%AA%E5%85%B3%E8%81%94/</guid>
      <description>关于 Rails 的模型自关联有一个非常有意思的题目，大概是这样的： lisa = Person.create(name:&amp;#39;Lisa&amp;#39;) tom = Person.create(name:&amp;#39;Tom&amp;#39;,parent_id:lisa.id) andy = Person.create(name:&amp;#39;Andy&amp;#39;,parent_id:lisa.id) tom.parent.name =&amp;gt; &amp;#39;Lisa&amp;#39; lisa.children.map(&amp;amp;:name) =&amp;gt; [&amp;#39;Tom&amp;#39;,&amp;#39;Andy&amp;#39;] thomas = Person.create(name: &amp;#39;Thomas&amp;#39;,parent_id: tom.id) peter = Person.create(name:&amp;#39;Peter&amp;#39;,parent_id:tom.id) gavin = Person.create(name:&amp;#39;Gavin&amp;#39;, parent_id: andy.id) lisa.grandchildren.map(&amp;amp;:name) =&amp;gt; [&amp;#39;Thomas&amp;#39;,&amp;#39;Peter&amp;#39;,&amp;#39;Gavin&amp;#39;] 问如何定义 Person 模型来满足以上需求？ 题目考察了对模型自关联的理解，通过审题我们可以得出</description>
    </item>
    
    <item>
      <title>ruby随机生成字符串</title>
      <link>https://dccmmtop.github.io/posts/ruby%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 12 Aug 2018 10:23:46 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ruby%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>shuffle ((&amp;#34;0&amp;#34;..&amp;#34;9&amp;#34;).to_a + (&amp;#34;A&amp;#34;..&amp;#34;Z&amp;#34;).to_a).shuffle[0..6].to_a.join shuffle: 随机排列，中文名称是洗牌 sample ((&amp;#34;0&amp;#34;..&amp;#34;9&amp;#34;).to_a + (&amp;#34;A&amp;#34;..&amp;#34;Z&amp;#34;).to_a).sample(6).join * [*&amp;#39;0&amp;#39;..&amp;#39;9&amp;#39;,*&amp;#39;A&amp;#39;..&amp;#39;Z&amp;#39;].sample(6).join *的意思是将范围展开</description>
    </item>
    
    <item>
      <title>rails_console好用的技巧</title>
      <link>https://dccmmtop.github.io/posts/rails_console%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Tue, 07 Aug 2018 23:58:40 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/rails_console%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7/</guid>
      <description>用 app 来调用 routes，比如 app.posts_path, app.topic_path(1) irb &amp;gt; app.topics_path =&amp;gt; &amp;#34;/topics&amp;#34; irb &amp;gt; app.get(app.root_path) ...... =&amp;gt; 200 用 helper 来调用 Helper 方法，比如: irb &amp;gt; helper.link_to(&amp;#34;Ruby China&amp;#34;, &amp;#34;http://ruby-china.org&amp;#34;) =&amp;gt; &amp;#34;&amp;lt;a href=\&amp;#34;http://ruby-china.org\&amp;#34;&amp;gt;Ruby China&amp;lt;/a&amp;gt;&amp;#34; irb &amp;gt; helper.truncate(&amp;#34;Here is Ruby China.&amp;#34;, length: 15) =&amp;gt; &amp;#34;Here is Ruby...&amp;#34; 使用 source_location 方法查看方法在那里定义的, 比如: irb &amp;gt;Topic.instance_method(:destroy).source_location =&amp;gt; [&amp;#34;/Users/jason/.rvm/gems/ruby-1.9.3-p0/gems/mongoid-2.4.8/lib/mongoid/persistence.rb&amp;#34;, 30] irb &amp;gt;Topic.method(:destroy_all).source_location =&amp;gt; [&amp;#34;/Users/jason/.rvm/gems/ruby-1.9.3-p0/gems/mongoid-2.4.8/lib/mongoid/persistence.rb&amp;#34;, 239]</description>
    </item>
    
    <item>
      <title>ActiveRecord_Store用法示例</title>
      <link>https://dccmmtop.github.io/posts/activerecord_store%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Tue, 07 Aug 2018 22:53:19 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/activerecord_store%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B/</guid>
      <description>转载 http://api.rubyonrails.org/classes/ActiveRecord/Store.html 阅读 http://api.rubyonrails.org 相关的笔记 使用 Model 里面的一个字段作为一个序列化的封装，用来存储一个 key/value 文档里面提到，对应的存储字段的类型最好是 text， 以便确保有足够的存储空间 Make sure that you declare the database column used for the serialized store as a text, so there&amp;#39;s plenty of room. 假设 Model</description>
    </item>
    
    <item>
      <title>wget整站下载</title>
      <link>https://dccmmtop.github.io/posts/wget%E6%95%B4%E7%AB%99%E4%B8%8B%E8%BD%BD/</link>
      <pubDate>Fri, 22 Jun 2018 10:56:46 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/wget%E6%95%B4%E7%AB%99%E4%B8%8B%E8%BD%BD/</guid>
      <description>这个命令可以以递归的方式下载整站，并可以将下载的页面中的链接转换为本地链接。 wget 加上参数之后，即可成为相当强大的下载工具。 wget -r -p -np -k http://xxx.com/abc/ -r, &amp;ndash;recursive（递归） specify recursive download.（指</description>
    </item>
    
    <item>
      <title>部署Rails</title>
      <link>https://dccmmtop.github.io/posts/%E9%83%A8%E7%BD%B2rails/</link>
      <pubDate>Tue, 29 May 2018 15:26:09 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/%E9%83%A8%E7%BD%B2rails/</guid>
      <description>添加新用户 在服务器添加一个新的用户，用户名为 deploy教程 执行命令sudo adduser 用户名 按提示输入密码 设置一些个人信息，可以直接按 enter 键，设为空 添加权限 在 root 用户下，打开/etc/sudoers文件 # # This file MUST</description>
    </item>
    
    <item>
      <title>ssh免密码登录</title>
      <link>https://dccmmtop.github.io/posts/ssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</link>
      <pubDate>Tue, 29 May 2018 11:24:54 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/posts/ssh%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</guid>
      <description>生成 key 在本地执行ssh-keygen 将本地的公钥拷贝到远程服务器 ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22222 username@ip</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://dccmmtop.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dccmmtop@foxmail.com (dc)</author>
      <guid>https://dccmmtop.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
