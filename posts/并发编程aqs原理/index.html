<!doctype html><html><head><title>并发编程AQS原理 // 超的博客</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="并发编程AQS原理"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:locale" content="zh"><meta property="og:url" content="https://dccmmtop.github.io/posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Baqs%E5%8E%9F%E7%90%86/"><link rel=icon type=image/x-icon href=../../favicon.ico><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<link href=https://dccmmtop.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://dccmmtop.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://dccmmtop.github.io/css/style.css><link rel=stylesheet href=https://dccmmtop.github.io/css/custom.css><link rel=stylesheet href=https://dccmmtop.github.io/css/copy-to-clipboard.css><script src=https://dccmmtop.github.io/js/fastsearch.js></script>
<script src=https://dccmmtop.github.io/js/fuse.js></script>
<script src=https://dccmmtop.github.io/js/custom.js></script>
<script src=https://dccmmtop.github.io/js/copy-to-clipboard.js></script><meta name=generator content="Hugo 0.104.3"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=https://dccmmtop.github.io/>超的博客</a><nav id=main-nav><a class=main-nav-link href=../../posts/>文章</a>
<a class=main-nav-link href=../../tags/>标签</a>
<a class=main-nav-link href=../../about/>关于</a>
<a class=main-nav-link id=search><input id=inputSearch placeholder=search><svg t="1634282825021" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="2401" width="15" height="15"><path d="M1005.312 914.752 806.784 716.288A448 448 0 100 448a448 448 0 00716.288 358.784l198.4 198.4a64 64 0 1090.624-90.432zM448 767.936A320 320 0 11448 128a320 320 0 010 640z" fill="#262626" p-id="2402"/></svg></a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div><div class="modal fade" id=exampleModal tabindex=-1 role=dialog aria-labelledby=exampleModalLabel aria-hidden=true><div class=modal-dialog role=document><div class=modal-content><div class=modal-header><h5 class=modal-title id=exampleModalLabel>搜索结果</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class="modal-body searchResults"></div></div></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>并发编程AQS原理</h1></header><div class=article-meta><a href=../../posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Baqs%E5%8E%9F%E7%90%86/ class=article-date><time datetime=2022-10-06T15:14:59.000+00:00 itemprop=datePublished>2022-10-06</time></a></div><div class=article-entry itemprop=articleBody><p>JDK1.5以前只有synchronized同步锁，并且效率非常低，大神Doug Lea自己写了一套并发框架，这套框架的核心就在于AbstractQueuedSynchronizer类（即AQS），性能非常高，所以被引入JDK包中，即JUC。那么AQS是怎么实现的呢？本篇就是对AQS及其相关组件进行分析，了解其原理。</p><h2 id=aqs-的应用>AQS 的应用</h2><p>我们经常使用并发包中的阻塞队列(ArrayBlockingQueue), 可重入锁（ReentrantLock），线程栅栏（CountDownLatch）等一些工具底层都是由AQS实现的</p><h2 id=aqs-大致结构>AQS 大致结构</h2><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020221006153454.png alt></p><h2 id=reentrantlock-实现原理>ReentrantLock 实现原理</h2><p>ReentrantLock 使用简单，我们就以这个类为切入口，学习一下如何利用 AQS 实现加锁释放锁的功能，以及公平和非公平锁实现的差别.</p><h3 id=加锁>加锁</h3><p>查看 ReentrantLock 的构造方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 无参构造器默认构造一个非公平锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>ReentrantLock</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    sync <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> NonfairSync<span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 可以指定使用公平锁还是非公平锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>ReentrantLock</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>boolean</span> fair<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    sync <span style=color:#ff79c6>=</span> fair <span style=color:#ff79c6>?</span> <span style=color:#ff79c6>new</span> FairSync<span style=color:#ff79c6>()</span> <span style=color:#ff79c6>:</span> <span style=color:#ff79c6>new</span> NonfairSync<span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>由此可知，ReentrantLock 的公平锁和非公平锁分别是由 <code>FairSync</code> 和 <code>NonfairSync</code>实现的，</p><p>由下面的结构图可知，<code>FairSync</code> 和 <code>NonfairSync</code> 都是继承至 <code>Sync</code> ,而 <code>Sync</code> 又是继承 AQS
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020221006160005.png alt></p><p>非公平锁加锁的代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 非公平锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>NonfairSync</span> <span style=color:#8be9fd;font-style:italic>extends</span> Sync <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>long</span> serialVersionUID <span style=color:#ff79c6>=</span> 7316153563782823691L<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 获取锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>lock</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 假设t1 线程正在尝试获取锁。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// CAS算法，把 state 从0修改为1，state 表示当前被加锁的次数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 从0变成1，表示t1第一次尝试获取锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>compareAndSetState<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>,</span> 1<span style=color:#ff79c6>))</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 如果修改成功，就把t1设置成正在持有锁的线程
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      setExclusiveOwnerThread<span style=color:#ff79c6>(</span>Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>currentThread</span><span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 未获取到锁...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      acquire<span style=color:#ff79c6>(</span>1<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>accquire(1) 实现:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>acquire</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> arg<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// tryAcquire(arg)：尝试抢锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// addWaiter(Node.EXCLUSIVE)，将当前线程构造成一个队列节点，并入队
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// acquireQueued（...） 将线程挂起，维护线程节点的状态
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!</span>tryAcquire<span style=color:#ff79c6>(</span>arg<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>&amp;&amp;</span>
</span></span><span style=display:flex><span>      acquireQueued<span style=color:#ff79c6>(</span>addWaiter<span style=color:#ff79c6>(</span>Node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>EXCLUSIVE</span><span style=color:#ff79c6>),</span> arg<span style=color:#ff79c6>))</span>
</span></span><span style=display:flex><span>    selfInterrupt<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>大致意思就是，线程再抢一次锁，如果失败了，就构造一个线程节点，然后把节点放入队列，将线程挂起，等待被唤醒</p><p>再次抢锁代码: tryAcquire(arg):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 非公平锁尝试获取锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>nonfairTryAcquire</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> acquires<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>final</span> Thread current <span style=color:#ff79c6>=</span> Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>currentThread</span><span style=color:#ff79c6>();</span> 
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 获取已经加锁的次数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> getState<span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 没有线程持有锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>c <span style=color:#ff79c6>==</span> 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 直接抢锁。没有判断队列中是否有线程排队，插队，不公平
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>compareAndSetState<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>,</span> acquires<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span> 
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 抢锁成功
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      setExclusiveOwnerThread<span style=color:#ff79c6>(</span>current<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>            <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 正在有线程持有锁，并且这个线程是自己(t1)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>current <span style=color:#ff79c6>==</span> getExclusiveOwnerThread<span style=color:#ff79c6>())</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// t1 已经获取到锁，无需再次获取锁，只需把锁的次数增加即可
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>int</span> nextc <span style=color:#ff79c6>=</span> c <span style=color:#ff79c6>+</span> acquires<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>nextc <span style=color:#ff79c6>&lt;</span> 0<span style=color:#ff79c6>)</span> <span style=color:#6272a4>// overflow  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> Error<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;Maximum lock count exceeded&#34;</span><span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 设置锁的次数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    setState<span style=color:#ff79c6>(</span>nextc<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>        
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><h4 id=公平锁的实现>公平锁的实现</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>tryAcquire</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> acquires<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>final</span> Thread current <span style=color:#ff79c6>=</span> Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>currentThread</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> getState<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>c <span style=color:#ff79c6>==</span> 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// hasQueuedPredecessors： 当线程尝试获取锁时，不是直接去抢，
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//    而是先判断是否存在队列，如果存在就不抢了，返回抢锁失败
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!</span>hasQueuedPredecessors<span style=color:#ff79c6>()</span> <span style=color:#ff79c6>&amp;&amp;</span>
</span></span><span style=display:flex><span>        compareAndSetState<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>,</span> acquires<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      setExclusiveOwnerThread<span style=color:#ff79c6>(</span>current<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>current <span style=color:#ff79c6>==</span> getExclusiveOwnerThread<span style=color:#ff79c6>())</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> nextc <span style=color:#ff79c6>=</span> c <span style=color:#ff79c6>+</span> acquires<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>nextc <span style=color:#ff79c6>&lt;</span> 0<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> Error<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;Maximum lock count exceeded&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    setState<span style=color:#ff79c6>(</span>nextc<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 是否存在队列并且(下一个待唤醒的线程不是本线程(准备重入锁))
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>hasQueuedPredecessors</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// The correctness of this depends on head being initialized
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// before tail and on head.next being accurate if the current
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// thread is first in queue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  Node t <span style=color:#ff79c6>=</span> tail<span style=color:#ff79c6>;</span> <span style=color:#6272a4>// Read fields in reverse initialization order
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  Node h <span style=color:#ff79c6>=</span> head<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  Node s<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> h <span style=color:#ff79c6>!=</span> t <span style=color:#ff79c6>&amp;&amp;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>((</span>s <span style=color:#ff79c6>=</span> h<span style=color:#ff79c6>.</span><span style=color:#50fa7b>next</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> s<span style=color:#ff79c6>.</span><span style=color:#50fa7b>thread</span> <span style=color:#ff79c6>!=</span> Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>currentThread</span><span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>于非公平锁相比，只有<code>tryAcquire</code> 方法的区别，</p><h4 id=为什么需要再次抢锁>为什么需要再次抢锁?</h4><p>因为抢锁失败有两种原因，1是当前线程确实没有获取到锁。2是当前线程之前已经获取到锁了，还想再获取一次。</p><p>对于1这种情况，让线程再抢一次，可能会抢到锁，就不用调用系统api把线程挂起，提高性能</p><p>对于2， 只需改变加锁的次数，就可以标记当前线程已经加锁的次数了，再释放锁时，对应的减成0就可以认为当前线程已经完全释放锁了，这就是可重入锁的实现原理</p><h4 id=构造队列节点及入队>构造队列节点及入队</h4><p>下面看一下构造线程节点的实现:</p><p>addWaiter()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> Node <span style=color:#50fa7b>addWaiter</span><span style=color:#ff79c6>(</span>Node mode<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 以当前线程为参数，构造一个新的 node，记作当前线程节点 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  Node node <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> Node<span style=color:#ff79c6>(</span>Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>currentThread</span><span style=color:#ff79c6>(),</span> mode<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 在最开始，tail 和 pred 肯定都是null,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  Node pred <span style=color:#ff79c6>=</span> tail<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 最开始不会进入下面，只有队列不为空时，才会进入
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>pred <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>prev</span> <span style=color:#ff79c6>=</span> pred<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将节点加入队尾
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>compareAndSetTail<span style=color:#ff79c6>(</span>pred<span style=color:#ff79c6>,</span> node<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      pred<span style=color:#ff79c6>.</span><span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> node<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 而是由 enq(node) 构造节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  enq<span style=color:#ff79c6>(</span>node<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> node<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> Node <span style=color:#50fa7b>enq</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>final</span> Node node<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 开始了循环
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>for</span> <span style=color:#ff79c6>(;;)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    Node t <span style=color:#ff79c6>=</span> tail<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 最开始队列是空的。只有第一次循环会进入
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>t <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> <span style=color:#6272a4>// Must initialize
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#6272a4>// 构造了一个空的node节点当作队列的头节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>compareAndSetHead<span style=color:#ff79c6>(</span><span style=color:#ff79c6>new</span> Node<span style=color:#ff79c6>()))</span>
</span></span><span style=display:flex><span>        tail <span style=color:#ff79c6>=</span> head<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 第二次及后面的循环会走到这里
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#6272a4>// 先设置当前节点的前驱节点是 队尾节点。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>prev</span> <span style=color:#ff79c6>=</span> t<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 用CAS算法把当前节点 设置成队尾
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>compareAndSetTail<span style=color:#ff79c6>(</span>t<span style=color:#ff79c6>,</span> node<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 这样上一次的队尾t就不是队尾了，t 就有了后继节点node
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        t<span style=color:#ff79c6>.</span><span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> t<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>经过<code>addWaiter(Node node)</code> 方法后，队列中至少存在两个节点，第一个就是必须的空节点，不包含线程信息，第二个才是真正待执行的线程节点，作者为什么这么做呢？</p><p>我认为，队列中存放的不仅是待唤醒的线程节点，而是所有等待运行和正在运行的线程节点，因为已经拿到锁的正在运行的线程不需要被唤醒，所以也就不需要存储线程信息了。并且这个正在运行的线程节点是队列中的头节点</p><h4 id=线程挂起>线程挂起</h4><p>下面就要看<code>acquireQueued</code> 方法了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>acquireQueued</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>final</span> Node node<span style=color:#ff79c6>,</span> <span style=color:#8be9fd>int</span> arg<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>boolean</span> failed <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>try</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> interrupted <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 开始循环抢锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span> <span style=color:#ff79c6>(;;)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 获取当前接节点的前驱节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#8be9fd;font-style:italic>final</span> Node p <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>predecessor</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 如果前驱节点是头节点，并且抢锁成功
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>p <span style=color:#ff79c6>==</span> head <span style=color:#ff79c6>&amp;&amp;</span> tryAcquire<span style=color:#ff79c6>(</span>arg<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 把当前节点设置成头节点，setHead会清空node中的线程信息，和初始化时设置的空头节点一样
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        setHead<span style=color:#ff79c6>(</span>node<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 断开前驱节点，旧的 head 会被垃圾回收
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        p<span style=color:#ff79c6>.</span><span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>;</span> <span style=color:#6272a4>// help GC
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        failed <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> interrupted<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>//走到这里说明不是头节点，或者抢锁失败
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#6272a4>// shouldParkAfterFailedAcquire(p, node): 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#6272a4>//    检查 node 是否是可唤醒的（waitStatus == -1）,如果是，返回true
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#6272a4>//    如果node不是可唤醒的，并且node没有被取消掉，则将node设置设置为可唤醒，返回false,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#6272a4>//    下一次循环时就会返回false
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#6272a4>// parkAndCheckInterrupt(): 挂起线程
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>shouldParkAfterFailedAcquire<span style=color:#ff79c6>(</span>p<span style=color:#ff79c6>,</span> node<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>&amp;&amp;</span> parkAndCheckInterrupt<span style=color:#ff79c6>())</span>
</span></span><span style=display:flex><span>        interrupted <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>finally</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这个判断不会走，可以认为 failed 和 interrupted 标识这里无用。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 程序能走到这里，说明 (p ==head &amp;&amp; tryQcquire(arg)) 为true，那么 failed 和 interupted 恒为false
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 否则就会陷在循环中，无法到 finally 中。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>failed<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      cancelAcquire<span style=color:#ff79c6>(</span>node<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 把node设置为队列的头节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setHead</span><span style=color:#ff79c6>(</span>Node node<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  head <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 清空了线程信息
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>thread</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>prev</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>shouldParkAfterFailedAcquire(Node pred, Node node)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 接受两个参数，一个是当前节点的前驱节点，一个是当前节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>* 这里使用前驱节点中的waitStatus状态来判断当前节点是否可以被唤醒。
</span></span></span><span style=display:flex><span><span style=color:#6272a4>*/</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>shouldParkAfterFailedAcquire</span><span style=color:#ff79c6>(</span>Node pred<span style=color:#ff79c6>,</span> Node node<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 前驱节点的状态
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd>int</span> ws <span style=color:#ff79c6>=</span> pred<span style=color:#ff79c6>.</span><span style=color:#50fa7b>waitStatus</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 如果是可唤醒的，直接返回true
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>ws <span style=color:#ff79c6>==</span> Node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>SIGNAL</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>ws <span style=color:#ff79c6>&gt;</span> 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 标识前驱节点已经取消锁竞争，跳过这个前驱节点，继续向前查找
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>do</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 一直向前找
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>prev</span> <span style=color:#ff79c6>=</span> pred <span style=color:#ff79c6>=</span> pred<span style=color:#ff79c6>.</span><span style=color:#50fa7b>prev</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>while</span> <span style=color:#ff79c6>(</span>pred<span style=color:#ff79c6>.</span><span style=color:#50fa7b>waitStatus</span> <span style=color:#ff79c6>&gt;</span> 0<span style=color:#ff79c6>);</span> <span style=color:#6272a4>// 到不是已取消的节点为止
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 设置有效的前驱节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    pred<span style=color:#ff79c6>.</span><span style=color:#50fa7b>next</span> <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将前驱节点的 ws 设置可唤醒的
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    compareAndSetWaitStatus<span style=color:#ff79c6>(</span>pred<span style=color:#ff79c6>,</span> ws<span style=color:#ff79c6>,</span> Node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>SIGNAL</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><h2 id=释放锁>释放锁</h2><p>释放锁的逻辑比较简单，</p><ol><li>减少加锁的次数(state)，如果state == 0, 代表当前线程可以释放锁，然后把持有锁的线程标记为空</li><li>唤醒队列中第一个待运行的线程也就是第二个节点，因为第一个节点是当前已获取到锁正在运行线程</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>release</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> arg<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>tryRelease<span style=color:#ff79c6>(</span>arg<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    Node h <span style=color:#ff79c6>=</span> head<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 头节点不为空，且头节点的waitStatus不是默认状态
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>h <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> h<span style=color:#ff79c6>.</span><span style=color:#50fa7b>waitStatus</span> <span style=color:#ff79c6>!=</span> 0<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>//传入的是头节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      unparkSuccessor<span style=color:#ff79c6>(</span>h<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 释放锁
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>protected</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>tryRelease</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> releases<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> c <span style=color:#ff79c6>=</span> getState<span style=color:#ff79c6>()</span> <span style=color:#ff79c6>-</span> releases<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>currentThread</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>!=</span> getExclusiveOwnerThread<span style=color:#ff79c6>())</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> IllegalMonitorStateException<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>boolean</span> free <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>c <span style=color:#ff79c6>==</span> 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    free <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    setExclusiveOwnerThread<span style=color:#ff79c6>(</span><span style=color:#ff79c6>null</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  setState<span style=color:#ff79c6>(</span>c<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> free<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>unparkSuccessor</span><span style=color:#ff79c6>(</span>Node node<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> ws <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>waitStatus</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>ws <span style=color:#ff79c6>&lt;</span> 0<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 再次将ws 置为0，这里暂时不清楚为什么重置状态
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    compareAndSetWaitStatus<span style=color:#ff79c6>(</span>node<span style=color:#ff79c6>,</span> ws<span style=color:#ff79c6>,</span> 0<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 获取传入节点的后继节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  Node s <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>.</span><span style=color:#50fa7b>next</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>s <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> s<span style=color:#ff79c6>.</span><span style=color:#50fa7b>waitStatus</span> <span style=color:#ff79c6>&gt;</span> 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    s <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> <span style=color:#ff79c6>(</span>Node t <span style=color:#ff79c6>=</span> tail<span style=color:#ff79c6>;</span> t <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> t <span style=color:#ff79c6>!=</span> node<span style=color:#ff79c6>;</span> t <span style=color:#ff79c6>=</span> t<span style=color:#ff79c6>.</span><span style=color:#50fa7b>prev</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>t<span style=color:#ff79c6>.</span><span style=color:#50fa7b>waitStatus</span> <span style=color:#ff79c6>&lt;=</span> 0<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>        s <span style=color:#ff79c6>=</span> t<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 唤醒后继节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>s <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    LockSupport<span style=color:#ff79c6>.</span><span style=color:#50fa7b>unpark</span><span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>.</span><span style=color:#50fa7b>thread</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><h2 id=获取锁的流程图>获取锁的流程图</h2><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020221007094312.png alt></p><h2 id=队列中节点状态>队列中节点状态</h2><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020221009092730.png alt></p></div><div class=article-toc><h3></h3><nav id=TableOfContents><ul><li><a href=#aqs-的应用>AQS 的应用</a></li><li><a href=#aqs-大致结构>AQS 大致结构</a></li><li><a href=#reentrantlock-实现原理>ReentrantLock 实现原理</a><ul><li><a href=#加锁>加锁</a></li></ul></li><li><a href=#释放锁>释放锁</a></li><li><a href=#获取锁的流程图>获取锁的流程图</a></li><li><a href=#队列中节点状态>队列中节点状态</a></li></ul></nav></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/java>java</a></li></ul></footer></div><nav id=article-nav><a href=../../posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsemaphore%E5%92%8Ccountdownlatch%E7%9A%84%E7%94%A8%E6%B3%95/ id=article-nav-newer class=article-nav-link-wrap><div class=article-nav-title><span>&lt;</span>&nbsp;
并发编程之Semaphore和CountDownLatch的用法</div></a><a href=../../posts/yml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>yml配置文件读取&nbsp;<span>></span></div></a></nav></article></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022 dc<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script><script>document.getElementById("main-nav-toggle").addEventListener("click",function(){var e=document.getElementById("header");e.classList.contains("mobile-on")?e.classList.remove("mobile-on"):e.classList.add("mobile-on")})</script></footer></div></body></html>