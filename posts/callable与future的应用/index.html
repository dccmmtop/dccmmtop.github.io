<!doctype html><html><head><title>Callable与Future的应用 // 超的博客</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Callable与Future的应用"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:locale" content="zh"><meta property="og:url" content="https://dccmmtop.github.io/posts/callable%E4%B8%8Efuture%E7%9A%84%E5%BA%94%E7%94%A8/"><link rel=icon type=image/x-icon href=../../favicon.ico><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<link href=https://dccmmtop.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://dccmmtop.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://dccmmtop.github.io/css/style.css><link rel=stylesheet href=https://dccmmtop.github.io/css/custom.css><link rel=stylesheet href=https://dccmmtop.github.io/css/copy-to-clipboard.css><script src=https://dccmmtop.github.io/js/fastsearch.js></script>
<script src=https://dccmmtop.github.io/js/fuse.js></script>
<script src=https://dccmmtop.github.io/js/custom.js></script>
<script src=https://dccmmtop.github.io/js/copy-to-clipboard.js></script><meta name=google-site-verification content="15Pa8fZ9IfDWw5gRPmi3YLNnHcciUc4a3Hv8cNKm-Ac"><meta name=generator content="Hugo 0.111.3"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=https://dccmmtop.github.io/>超的博客</a><nav id=main-nav><a class=main-nav-link href=../../posts/>文章</a>
<a class=main-nav-link href=../../tags/>标签</a>
<a class=main-nav-link href=../../about/>我</a>
<a class=main-nav-link id=search><input id=inputSearch placeholder=search><svg t="1634282825021" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="2401" width="15" height="15"><path d="M1005.312 914.752 806.784 716.288A448 448 0 100 448a448 448 0 00716.288 358.784l198.4 198.4a64 64 0 1090.624-90.432zM448 767.936A320 320 0 11448 128a320 320 0 010 640z" fill="#262626" p-id="2402"/></svg></a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div><div class="modal fade" id=exampleModal tabindex=-1 role=dialog aria-labelledby=exampleModalLabel aria-hidden=true><div class=modal-dialog role=document><div class=modal-content><div class=modal-header><h5 class=modal-title id=exampleModalLabel>搜索结果</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class="modal-body searchResults"></div></div></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>Callable与Future的应用</h1></header><div class=article-meta><a href=../../posts/callable%E4%B8%8Efuture%E7%9A%84%E5%BA%94%E7%94%A8/ class=article-date><time datetime=2022-10-29T17:15:31.000+00:00 itemprop=datePublished>2022-10-29</time></a></div><div class=article-entry itemprop=articleBody><h1 id=为什么需要-callable>为什么需要 Callable</h1><p>无论是继承 Thread 类，还是实现 Runnale 接口，或者使用线程池的 execute 方法去执行一个异步任务，都无法将这个任务的返回值带出来，以 Runnale 接口为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @since   JDK1.0
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span>@FunctionalInterface
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>interface</span> <span style=color:#50fa7b>Runnable</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>abstract</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>run</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>可以看到 run() 方法没有参数，没有返回值，没有抛出异常，因此不能适用于那些需要异步任务返回值得场景，由此就诞生了可以获取异步任务结果的工具： Callable</p><h1 id=callable>Callable</h1><p>又是 Doug Lea 大师</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see Executor
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @since 1.5
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Doug Lea
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @param &lt;V&gt; the result type of method {@code call}
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span>@FunctionalInterface
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>interface</span> <span style=color:#50fa7b>Callable</span><span style=color:#ff79c6>&lt;</span>V<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    V <span style=color:#50fa7b>call</span><span style=color:#ff79c6>()</span> <span style=color:#8be9fd;font-style:italic>throws</span> Exception<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>Callable 是一个泛型接口，里面只有一个方法，call(), 可以返回泛型值V, Cacheable 与 Runnable 接口很是相似，下面看一下他们之间的区别</p><h1 id=callable-vs-runnable>Callable VS Runnable</h1><p>两个接口都是用于多线程执行任务的，但是他们的使用场景的差别还是很大的。</p><h2 id=执行机制上的差别>执行机制上的差别</h2><p>Runnable 可以用在Thread类中，也可以在 ExecutorService 中配合线程池使用，但是 Callable 只能用于 ExecutorService 中，Thread 类中没有 Cacheable 的身影：</p><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/2022-10-29-17-33-24.png alt></p><h2 id=异常处理的差别>异常处理的差别</h2><p>Runnable 接口中的 run 方法签名上没有 throws, 自然也不能向上传播受检异常。而 Callable 接口中的 call f方法可以向上抛出异常。</p><p>区别总结如下：</p><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/2022-10-29-17-35-51.png alt></p><h1 id=callable-在线程池中的应用>Callable 在线程池中的应用</h1><p>上面说过，Callable 接口只能在 ExecutorService 中使用，下面看一下如何使用的</p><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/2022-10-29-17-41-10.png alt></p><p>可以看到在 submit 方法中可以接收一个实现了 Callable 接口的任务， 返回的是 Future 类型。而 execute 方法无返回值。 那么 Future 是什么呢？ 如何通过 Future 拿到返回值呢？</p><h1 id=future>Future</h1><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/2022-10-29-17-45-23.png alt></p><p>Future 是一个接口，通过方法名就可以看出他们的用途：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 取消任务
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>cancel</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>boolean</span> mayInterruptIfRunning<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 获取任务执行结果
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>V <span style=color:#50fa7b>get</span><span style=color:#ff79c6>()</span> <span style=color:#8be9fd;font-style:italic>throws</span> InterruptedException<span style=color:#ff79c6>,</span> ExecutionException<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 获取任务执行结果，带有超时时间限制
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>V <span style=color:#50fa7b>get</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>long</span> timeout<span style=color:#ff79c6>,</span> TimeUnit unit<span style=color:#ff79c6>)</span> <span style=color:#8be9fd;font-style:italic>throws</span> InterruptedException<span style=color:#ff79c6>,</span> ExecutionException<span style=color:#ff79c6>,</span>  TimeoutException<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 判断任务是否已经取消
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isCancelled</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 判断任务是否已经结束
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isDone</span><span style=color:#ff79c6>();</span>
</span></span></code></pre></div><p>看一下如何使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>FutureDemo</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>main</span><span style=color:#ff79c6>(</span>String<span style=color:#ff79c6>[]</span> args<span style=color:#ff79c6>)</span> <span style=color:#8be9fd;font-style:italic>throws</span> InterruptedException<span style=color:#ff79c6>,</span> ExecutionException <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#ff79c6>=</span> Executors<span style=color:#ff79c6>.</span><span style=color:#50fa7b>newSingleThreadExecutor</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 使用 Callable ，可以获取返回值
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Callable<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> callable <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>()</span> <span style=color:#ff79c6>-&gt;</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>           System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;进入 Callable 的 call 方法&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 模拟子线程任务，在此睡眠 2s，
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// 小细节：由于 call 方法会抛出 Exception，这里不用像使用 Runnable 的run 方法那样 try/catch 了
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>sleep</span><span style=color:#ff79c6>(</span><span style=color:#bd93f9>5000</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;Hello from Callable&#34;</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;提交 Callable 到线程池&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        Future<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> future <span style=color:#ff79c6>=</span> executorService<span style=color:#ff79c6>.</span><span style=color:#50fa7b>submit</span><span style=color:#ff79c6>(</span>callable<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;主线程继续执行&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;主线程等待获取 Future 结果&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//        //检查任务是否做完
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//        while(!future.isDone()) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//            System.out.println(&#34;Task is still not done...&#34;);
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//            Thread.sleep(1000);
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//        }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// Future.get() blocks until the result is available
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        String result <span style=color:#ff79c6>=</span> future<span style=color:#ff79c6>.</span><span style=color:#50fa7b>get</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>       System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;主线程获取到 Future 结果: &#34;</span> <span style=color:#ff79c6>+</span>  result<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        executorService<span style=color:#ff79c6>.</span><span style=color:#50fa7b>shutdown</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>结果如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>提交 Callable 到线程池
</span></span><span style=display:flex><span>主线程继续执行
</span></span><span style=display:flex><span>主线程等待获取 Future 结果
</span></span><span style=display:flex><span>进入 Callable 的 call 方法
</span></span><span style=display:flex><span>主线程获取到 Future 结果: Hello from Callable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Process finished with exit code 0
</span></span></code></pre></div><p>如果子程序运行时间过长，或者其他原因，我们想 cancel 子程序的运行，则我们可以使用 Future 提供的 cancel 方法，继续对程序做一些修改</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span><span style=color:#ff79c6>(!</span>future<span style=color:#ff79c6>.</span><span style=color:#50fa7b>isDone</span><span style=color:#ff79c6>())</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;子线程任务还没有结束...&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>   Thread<span style=color:#ff79c6>.</span><span style=color:#50fa7b>sleep</span><span style=color:#ff79c6>(</span><span style=color:#bd93f9>1000</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#8be9fd>double</span> elapsedTimeInSec <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>(</span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>nanoTime</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>-</span> startTime<span style=color:#ff79c6>)/</span><span style=color:#bd93f9>1000000000.0</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 如果程序运行时间大于 1s，则取消子线程的运行
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>   <span style=color:#ff79c6>if</span><span style=color:#ff79c6>(</span>elapsedTimeInSec <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>1</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      future<span style=color:#ff79c6>.</span><span style=color:#50fa7b>cancel</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>true</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>特别注意的是，如果使用 cancel 方法取消了任务， get() 方法会抛出一个 CancellationException 异常。</p><p>到这里已经知道和配合使用 Cacheable 和 Future 来获取异步任务的返回值了。总结就只有3点：</p><ol><li>待执行的任务要实现 Callable 接口中的</li><li>使用线程池中的submit 方法</li><li>通过 Future 获取任务的返回值</li></ol><p>刚刚我们看 ExecutorService 中的 submit 方法返回的是 Future 接口，然后通过接口中的get 方法获取任务的返回值，其实 submit 返回的是 Future 的实现类： FutureTask, 至于 FutureTask 是如何配合线程池拿到任务的返回值，就需要深入源码查看底层实现了，这个以后再新写一遍博客讲解。</p><h1 id=参考>参考</h1><p><a href=http://www.lllpan.top/article/102>http://www.lllpan.top/article/102</a></p></div><div class=article-toc><h3></h3><nav id=TableOfContents><ul><li><a href=#执行机制上的差别>执行机制上的差别</a></li><li><a href=#异常处理的差别>异常处理的差别</a></li></ul></nav></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/%20tags/java>java</a></li></ul></footer></div><nav id=article-nav><a href=../../posts/maven%E5%AE%8C%E5%85%A8%E4%BE%9D%E8%B5%96%E6%9C%AC%E5%9C%B0%E5%BA%93/ id=article-nav-newer class=article-nav-link-wrap><div class=article-nav-title><span>&lt;</span>&nbsp;
maven完全依赖本地库</div></a><a href=../../posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bforkjoin%E6%A1%86%E6%9E%B6/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>并发编程之 ForkJoin 框架&nbsp;<span>></span></div></a></nav></article></section><div><script src=https://utteranc.es/client.js repo=dccmmtop/dccmmtop.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></div><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2023 dc<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script><script>document.getElementById("main-nav-toggle").addEventListener("click",function(){var e=document.getElementById("header");e.classList.contains("mobile-on")?e.classList.remove("mobile-on"):e.classList.add("mobile-on")})</script><style>#footer-info{line-height:1.4em;font-size:10px}.custom-blog-info{font-family:long cang,cursive;border-top:1px dashed #333;font-size:16px;margin-top:10px;padding-top:10px;line-height:1.4em}</style></footer></div></body></html>