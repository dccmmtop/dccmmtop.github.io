<!doctype html><html><head><title>java常量池 // 超的博客</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="java常量池"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:locale" content="zh"><meta property="og:url" content="https://dccmmtop.github.io/posts/java%E5%B8%B8%E9%87%8F%E6%B1%A0/"><link rel=icon type=image/x-icon href=../../favicon.ico><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<link href=https://dccmmtop.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://dccmmtop.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://dccmmtop.github.io/css/style.css><link rel=stylesheet href=https://dccmmtop.github.io/css/custom.css><link rel=stylesheet href=https://dccmmtop.github.io/css/copy-to-clipboard.css><script src=https://dccmmtop.github.io/js/fastsearch.js></script>
<script src=https://dccmmtop.github.io/js/fuse.js></script>
<script src=https://dccmmtop.github.io/js/custom.js></script>
<script src=https://dccmmtop.github.io/js/copy-to-clipboard.js></script><meta name=generator content="Hugo 0.103.1"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=https://dccmmtop.github.io/>超的博客</a><nav id=main-nav><a class=main-nav-link href=../../posts/>文章</a>
<a class=main-nav-link href=../../tags/>标签</a>
<a class=main-nav-link href=../../about/>关于</a>
<a class=main-nav-link id=search><input id=inputSearch placeholder=search><svg t="1634282825021" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="2401" width="15" height="15"><path d="M1005.312 914.752 806.784 716.288A448 448 0 100 448a448 448 0 00716.288 358.784l198.4 198.4a64 64 0 1090.624-90.432zM448 767.936A320 320 0 11448 128a320 320 0 010 640z" fill="#262626" p-id="2402"/></svg></a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div><div class="modal fade" id=exampleModal tabindex=-1 role=dialog aria-labelledby=exampleModalLabel aria-hidden=true><div class=modal-dialog role=document><div class=modal-content><div class=modal-header><h5 class=modal-title id=exampleModalLabel>搜索结果</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class="modal-body searchResults"></div></div></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>java常量池</h1></header><div class=article-meta><a href=../../posts/java%E5%B8%B8%E9%87%8F%E6%B1%A0/ class=article-date><time datetime=2022-09-15T10:05:51.000+00:00 itemprop=datePublished>2022-09-15</time></a></div><div class=article-entry itemprop=articleBody><h2 id=class常量池>Class常量池</h2><p>Class常量池可以理解为class文件中的资源仓库，class 文件中除了包含类信息，方法，字段，接口信息之外还有常量池信息，用于存放编译期生成的各种字面量和符号引用。</p><p>如下:
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220917111234.png alt></p><p>常量池主要包含两大类常量: 字面量和符号引用。</p><h2 id=字面量>字面量</h2><p>字面量就是有字符串和数字等构成的常量。</p><p>字面量只能以右值出现，int a = 1, a 是左值，1 是右值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> a <span style=color:#ff79c6>=</span>1<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> b <span style=color:#ff79c6>=</span>2<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>String c<span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;abc&#34;</span>；
</span></span><span style=display:flex><span>String d<span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;abc&#34;</span>；
</span></span></code></pre></div><p>1 2 &ldquo;abc&rdquo; 都是常量</p><h2 id=符号引用>符号引用</h2><p>符号引用是编译原理中概念，是相对于直接引用来说的，主要包括一三类常量:</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>上面的 a b就是字段名 ，是符号引用。 还有包名+类名 组成的类的全限定名，方法名，以及() 都是符号引用</p><h2 id=运行常量池>运行常量池</h2><p>存在class 文件的常量都是静态信息，只有到运行时被加载到内存中，这些符号才有具体的内存地址，这些常量一旦被加载内存中，就变成运行常量池，对应的符号引用在程序运行时，会被加载到内存区域的代码直接引用，也就我们说的动态链接，例如： compute() 这个符号引用在运行时就会被转化成compute()方法具体代码在内存中的地址，</p><h2 id=字符串常量池>字符串常量池</h2><p>在内存中专门存放字符串字面量的区域称作字符串常量池，那么除了把对象放入堆中之外。还需要独立的区域存放字符串字面量呢？</p><p>主要是为了性能：</p><ul><li>字符串的分配和其他对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，需要大量频繁的创建，极大影响了程序的性能</li></ul><p>JVM 为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：</p><ol><li>为字符串开辟一个字符串常量池，类似于缓存</li><li>创建字符串常量时，首先查询字符串常量池是否已经存在</li><li>若存在该字符串，直接返回引用示例，不存在，实例化该字符串并放入池中</li></ol><h3 id=什么时候会把字符串常量放入常量池>什么时候会把字符串常量放入常量池</h3><ol><li>直接赋值字符串</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;hello&#34;</span>；
</span></span></code></pre></div><p><strong>这种方式创建的字符串只会在常量池中，不会在堆中额外创建一个对象</strong></p><p>当再次创建字符串 <code>String s1 = "hello"</code> 时，先去常量池中通过 <code>equals(key)</code> 方法判断是否有相同的对象，如果有直接返回对象在常量池的引用。如果没有会在常量池新新建对象，再返回引用</p><p>所以有如下结果:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;hello&#34;</span>；
</span></span><span style=display:flex><span>String s1 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;hello&#34;</span>；
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span> s <span style=color:#ff79c6>==</span> 1<span style=color:#ff79c6>)</span> <span style=color:#6272a4>// true. s 和 s1 地址一样
</span></span></span></code></pre></div><ol start=2><li>new String()</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>);</span>
</span></span></code></pre></div><p>这中方式创建字符串会保证常量池中和堆中都有这个对象，最后返回堆中的地址:
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220917115755.png alt></p><ol start=3><li>intern 方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>)</span>；
</span></span><span style=display:flex><span>String s1 <span style=color:#ff79c6>=</span> s<span style=color:#ff79c6>.</span><span style=color:#50fa7b>intern</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s <span style=color:#ff79c6>==</span> s1<span style=color:#ff79c6>)</span> <span style=color:#6272a4>// false
</span></span></span></code></pre></div><p>String intern 方法是一个 native 方法，如果池中已经包含一个等于此 String 对象的字符串，则返回池中的字符串，<strong>否则将intern 返回的引用指向当前字符串（在 jdk 1.6 中，需要将s1字符串复制到常量池中）</strong></p><p>在第一种情况，<code>String s = "hello"</code> 会将 <code>hello</code> 放入常量池中， 第二种情况 <code>String s = new String("hello")</code> 也会将 <code>hello</code> 放入常量池中，那么什么情况下常量池会没有我们要取的字符串呢？</p><p>常量池存放的一定是不可变的字面量, 无论是 <code>String s = "hello"</code> 还是 <code>String s = new String("hello")</code> 都有一个明确的字面量: <code>hello</code> 如果是下面这种情况:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>+</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;World&#34;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>String s1 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;helloWorld&#34;</span>；
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s <span style=color:#ff79c6>==</span> s1<span style=color:#ff79c6>)</span> <span style=color:#6272a4>// false
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s <span style=color:#ff79c6>==</span> s<span style=color:#ff79c6>.</span><span style=color:#50fa7b>intern</span><span style=color:#ff79c6>())</span> <span style=color:#6272a4>// true
</span></span></span></code></pre></div><p>常量池中有 <code>hello</code> 和 <code>World</code> 但是没有 <code>helloWorld</code>， 因为在代码中没有明确的<code>helloWorld</code>字面量，所以 s != s1, 常量池中没有 <code>helloWorld</code> 字面量，所以 <code>s.intern()</code> 返回的是堆中的地址，故而 <code>s == s.intern()</code></p><p>再看下面一种情况:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;hello&#34;</span> <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34;World&#34;</span>；
</span></span><span style=display:flex><span>String s1 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;helloWorld&#34;</span>； 
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s <span style=color:#ff79c6>==</span> s1<span style=color:#ff79c6>)</span> <span style=color:#6272a4>// true
</span></span></span></code></pre></div><p>代码中也没有明确的<code>helloWorld</code> 字面量， 为什么 s == s1 呢， 因为 <code>hello</code> 和 <code>World</code> 都是<strong>不可变</strong>的字面量，而不是一个引用，在 <code>String s = "hello" + "World"</code> 时， 编译器可以优化成 <code>s = "helloWorld"</code> ， 所以 s == s1 ，那为什么 <code>String s = new String("hello") + new String("World")</code> 不会被编译器优化呢？ 因为 <code>new String("hello")</code> 是一个对象，返回的是引用，而不是一个不会变化的字面量，后面这个引用地址可能会指向其他的对象，优化后可能会出现错误。同理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>String s1 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;World&#34;</span>；
</span></span><span style=display:flex><span>String s2 <span style=color:#ff79c6>=</span> s <span style=color:#ff79c6>+</span> s1<span style=color:#ff79c6>;</span> <span style=color:#6272a4>// 不会编译器优化成 &#34;helloWorld&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>String s3 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;helloWorld&#34;</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s3 <span style=color:#ff79c6>==</span> s2<span style=color:#ff79c6>);</span> <span style=color:#6272a4>// false
</span></span></span></code></pre></div><p>但是被 final 修饰的变量可以被优化，因为它不会发生变化了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>final</span> String s <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>;</span> <span style=color:#6272a4>// s 不会再被重新赋值
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>final</span> String s1 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;World&#34;</span>；
</span></span><span style=display:flex><span>String s2 <span style=color:#ff79c6>=</span> s <span style=color:#ff79c6>+</span> s1<span style=color:#ff79c6>;</span> <span style=color:#6272a4>// 编译器优化成 &#34;helloWorld&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>String s3 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;helloWorld&#34;</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s3 <span style=color:#ff79c6>==</span> s2<span style=color:#ff79c6>);</span> <span style=color:#6272a4>// true
</span></span></span></code></pre></div><p>再看下面一种情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>final</span> String s <span style=color:#ff79c6>=</span> getHello<span style=color:#ff79c6>();</span> <span style=color:#6272a4>// s 虽然不能再被重新赋值，但getHello() 方法返回的值可能会改变
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>final</span> String s1 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;World&#34;</span>；
</span></span><span style=display:flex><span>String s2 <span style=color:#ff79c6>=</span> s <span style=color:#ff79c6>+</span> s1<span style=color:#ff79c6>;</span> <span style=color:#6272a4>// 不会编译器优化成 &#34;helloWorld&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>String s3 <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;helloWorld&#34;</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s3 <span style=color:#ff79c6>==</span> s2<span style=color:#ff79c6>);</span> <span style=color:#6272a4>// false
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> String <span style=color:#50fa7b>getHello</span><span style=color:#ff79c6>(){</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;hello&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>s 的值无法再编译器确定，所以无法优化成字面量</p><p>再看最后一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span>String s1 <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>+</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;World&#34;</span><span style=color:#ff79c6>)</span>；
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s1 <span style=color:#ff79c6>==</span> s1<span style=color:#ff79c6>.</span><span style=color:#50fa7b>intern</span><span style=color:#ff79c6>())</span> <span style=color:#6272a4>// true
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>String s <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;ja&#34;</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>+</span> <span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;va&#34;</span><span style=color:#ff79c6>)</span>；
</span></span><span style=display:flex><span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>s <span style=color:#ff79c6>==</span> s<span style=color:#ff79c6>.</span><span style=color:#50fa7b>intern</span><span style=color:#ff79c6>())</span> <span style=color:#6272a4>// false
</span></span></span></code></pre></div><p>为什么同样的写法，结果却不一样呢？</p><p>intern() 方法优先返回常量池中的地址, 常量池不存在时，再返回堆中的地址， 第一个 s1 != s1.intern() 是符合我们直觉的，因为常量池中没有 helloWorld , 但是第二个 s == s.intern() 为false 就说不通了，难道常量池已经有 <code>java</code> 这个字面量了吗？ 是的， java 这个关键词，在jvm 启动或类加载期间肯定有 <code>java</code> 这个字符串已经放入到常量池中了， s.inern() 返回的是常量池中的地址.</p><h2 id=八种基本类型的包装类和对象池>八种基本类型的包装类和对象池</h2><p>java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫对象池，在堆上)，这些类是 Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外 Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理o大于127的这些类的对象。因为一般这种比较小的数用到的概率相对较大</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Test</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>main</span><span style=color:#ff79c6>(</span>String<span style=color:#ff79c6>[]</span> args<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//5种整形的包装类Byte,Short,Integer,Long,Character的对象，  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//在值小于127时可以使用对象池  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Integer i1 <span style=color:#ff79c6>=</span> 127<span style=color:#ff79c6>;</span>  <span style=color:#6272a4>//这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Integer i2 <span style=color:#ff79c6>=</span> 127<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i1 <span style=color:#ff79c6>==</span> i2<span style=color:#ff79c6>);</span><span style=color:#6272a4>//输出true  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//值大于127时，不会从对象池中取对象  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Integer i3 <span style=color:#ff79c6>=</span> 128<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        Integer i4 <span style=color:#ff79c6>=</span> 128<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i3 <span style=color:#ff79c6>==</span> i4<span style=color:#ff79c6>);</span><span style=color:#6272a4>//输出false  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//用new关键词新生成对象不会使用对象池
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Integer i5 <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> Integer<span style=color:#ff79c6>(</span>127<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>        Integer i6 <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> Integer<span style=color:#ff79c6>(</span>127<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i5 <span style=color:#ff79c6>==</span> i6<span style=color:#ff79c6>);</span><span style=color:#6272a4>//输出false 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//Boolean类也实现了对象池技术  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Boolean bool1 <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        Boolean bool2 <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>bool1 <span style=color:#ff79c6>==</span> bool3<span style=color:#ff79c6>);</span><span style=color:#6272a4>//输出true  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//浮点类型的包装类没有实现对象池技术  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Double d1 <span style=color:#ff79c6>=</span> 1<span style=color:#ff79c6>.</span><span style=color:#50fa7b>0</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        Double d2 <span style=color:#ff79c6>=</span> 1<span style=color:#ff79c6>.</span><span style=color:#50fa7b>0</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>d1 <span style=color:#ff79c6>==</span> d2<span style=color:#ff79c6>);</span><span style=color:#6272a4>//输出false  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span> 
</span></span></code></pre></div></div><div class=article-toc><h3></h3><nav id=TableOfContents><ul><li><a href=#class常量池>Class常量池</a></li><li><a href=#字面量>字面量</a></li><li><a href=#符号引用>符号引用</a></li><li><a href=#运行常量池>运行常量池</a></li><li><a href=#字符串常量池>字符串常量池</a><ul><li><a href=#什么时候会把字符串常量放入常量池>什么时候会把字符串常量放入常量池</a></li></ul></li><li><a href=#八种基本类型的包装类和对象池>八种基本类型的包装类和对象池</a></li></ul></nav></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/java>java</a></li></ul></footer></div><nav id=article-nav><a href=../../posts/gc%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3/ id=article-nav-newer class=article-nav-link-wrap><div class=article-nav-title><span>&lt;</span>&nbsp;
GC日志详解</div></a><a href=../../posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%AD%90%E6%80%A7%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>并发编程中的可见性,原子性，有序性问题&nbsp;<span>></span></div></a></nav></article></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022 dc<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script><script>document.getElementById("main-nav-toggle").addEventListener("click",function(){var e=document.getElementById("header");e.classList.contains("mobile-on")?e.classList.remove("mobile-on"):e.classList.add("mobile-on")})</script></footer></div></body></html>