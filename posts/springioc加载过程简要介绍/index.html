<!doctype html><html><head><title>spring IOC 加载过程简要介绍 // 超的博客</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="spring IOC 加载过程简要介绍"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:locale" content="zh"><meta property="og:url" content="https://dccmmtop.github.io/posts/springioc%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"><link rel=icon type=image/x-icon href=../../favicon.ico><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<link href=https://dccmmtop.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://dccmmtop.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://dccmmtop.github.io/css/style.css><link rel=stylesheet href=https://dccmmtop.github.io/css/custom.css><link rel=stylesheet href=https://dccmmtop.github.io/css/copy-to-clipboard.css><script src=https://dccmmtop.github.io/js/fastsearch.js></script>
<script src=https://dccmmtop.github.io/js/fuse.js></script>
<script src=https://dccmmtop.github.io/js/custom.js></script>
<script src=https://dccmmtop.github.io/js/copy-to-clipboard.js></script><meta name=google-site-verification content="15Pa8fZ9IfDWw5gRPmi3YLNnHcciUc4a3Hv8cNKm-Ac"><meta name=generator content="Hugo 0.105.0"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=https://dccmmtop.github.io/>超的博客</a><nav id=main-nav><a class=main-nav-link href=../../posts/>文章</a>
<a class=main-nav-link href=../../tags/>标签</a>
<a class=main-nav-link href=../../about/>我</a>
<a class=main-nav-link id=search><input id=inputSearch placeholder=search><svg t="1634282825021" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="2401" width="15" height="15"><path d="M1005.312 914.752 806.784 716.288A448 448 0 100 448a448 448 0 00716.288 358.784l198.4 198.4a64 64 0 1090.624-90.432zM448 767.936A320 320 0 11448 128a320 320 0 010 640z" fill="#262626" p-id="2402"/></svg></a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div><div class="modal fade" id=exampleModal tabindex=-1 role=dialog aria-labelledby=exampleModalLabel aria-hidden=true><div class=modal-dialog role=document><div class=modal-content><div class=modal-header><h5 class=modal-title id=exampleModalLabel>搜索结果</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class="modal-body searchResults"></div></div></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>spring IOC 加载过程简要介绍</h1></header><div class=article-meta><a href=../../posts/springioc%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/ class=article-date><time datetime=2022-11-04T14:48:39.000+00:00 itemprop=datePublished>2022-11-04</time></a></div><div class=article-entry itemprop=articleBody><p>本文从源码层面简要介绍一下 Spring IoC 加载过程，以及这个过程遇到的重点方法，重点类。</p><h2 id=new-annotationconfigapplicationcontext>new AnnotationConfigApplicationContext()</h2><p>一切的根源都要从 <code>new AnnotationConfigApplicationContext()</code> 方法开始，这是 Spring 启动的入口，先准备如下代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>ContextDemo</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>main</span><span style=color:#ff79c6>(</span>String<span style=color:#ff79c6>[]</span> args<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        AnnotationConfigApplicationContext context <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> AnnotationConfigApplicationContext<span style=color:#ff79c6>(</span>Config<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        context<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getBean</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;car&#34;</span><span style=color:#ff79c6>,</span>Car<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@Configuration
</span></span><span style=display:flex><span>@ComponentScan<span style=color:#ff79c6>(</span>basePackageClasses <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>{</span>Car<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>})</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Config</span><span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    @Bean
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> User1 <span style=color:#50fa7b>user</span><span style=color:#ff79c6>(){</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> User1<span style=color:#ff79c6>(</span>10<span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;dc1&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@Component
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Car</span>  <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> color<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> String name<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>User1</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>int</span> age<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> String name<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>进入 <code>new AnnotationConfigApplicationContext(Config.class);</code> 方法可见如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>AnnotationConfigApplicationContext</span><span style=color:#ff79c6>(</span>Class<span style=color:#ff79c6>&lt;?&gt;...</span> annotatedClasses<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>    register<span style=color:#ff79c6>(</span>annotatedClasses<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    refresh<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>再进入 <code>this()</code> 方法，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>AnnotationConfigApplicationContext</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>reader</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> AnnotatedBeanDefinitionReader<span style=color:#ff79c6>(</span><span style=color:#ff79c6>this</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>scanner</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ClassPathBeanDefinitionScanner<span style=color:#ff79c6>(</span><span style=color:#ff79c6>this</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>发现调用的 <code>AnnotationConfigApplicationContext</code> 无参构造器， 再调用一个类的无参构造器时，会先调用父类的无参构造器， 同时发现这个类的父类构造器如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#50fa7b>GenericApplicationContext</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>beanFactory</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> DefaultListableBeanFactory<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>方法很简单，只是 new 了一个 <code>beanFactory</code>, 从名称来看，这个属性是 bean 工厂。现在只知道 <code>AnnotationConfigApplicationContext</code> 中有一个 <code>beanFactory</code> 的字段，这个字段是从父类继承来的。</p><p>父类的构造方法已经结束，接着往下看， <code>this.reader = new AnnotatedBeanDefinitionReader(this);</code>, <code>this.scanner = new ClassPathBeanDefinitionScanner(this); </code>。初始化 <code>reader</code> 和 <code>scanner</code>.</p><ol><li>找到 <code>reader</code> 属性，会发现它是 <code>AnnotatedBeanDefinitionReader</code> 类型。看一下这个类型的注释说明：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * Convenient adapter for programmatic registration of annotated bean classes.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * This is an alternative to {@link ClassPathBeanDefinitionScanner}, applying
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * the same resolution of annotations but for explicitly registered classes only.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Juergen Hoeller
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Chris Beams
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Sam Brannen
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Phillip Webb
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @since 3.0
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see AnnotationConfigApplicationContext#register
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>AnnotatedBeanDefinitionReader</span> <span style=color:#ff79c6>{....}</span>
</span></span></code></pre></div><p>翻译一下：</p><blockquote><p>简便的适配器，用于注解 bean 类的注册。这是 ClassPathBeanDefinitionScanner 的替代方案，应用相同的注解，但仅适用于显式注册的类。</p></blockquote><p>意思就是可以替代 <code>ClassPathBeanDefinitionScanner</code> 使用，但是它只能用于我们手动注册的类。</p><ol start=2><li>找到<code>scanner</code> 属性，发现它正是 <code>ClassPathBeanDefinitionScanner</code> 类型。再看一下这个类的注释说明：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * A bean definition scanner that detects bean candidates on the classpath,
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * registering corresponding bean definitions with a given registry ({@code BeanFactory}
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * or {@code ApplicationContext}).
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * &lt;p&gt;Candidate classes are detected through configurable type filters. The
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * default filters include classes that are annotated with Spring&#39;s
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * {@link org.springframework.stereotype.Component @Component},
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * {@link org.springframework.stereotype.Repository @Repository},
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * {@link org.springframework.stereotype.Service @Service}, or
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * {@link org.springframework.stereotype.Controller @Controller} stereotype.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * &lt;p&gt;Also supports Java EE 6&#39;s {@link javax.annotation.ManagedBean} and
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * JSR-330&#39;s {@link javax.inject.Named} annotations, if available.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Mark Fisher
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Juergen Hoeller
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @author Chris Beams
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @since 2.5
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see AnnotationConfigApplicationContext#scan
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see org.springframework.stereotype.Component
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see org.springframework.stereotype.Repository
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see org.springframework.stereotype.Service
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see org.springframework.stereotype.Controller
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>ClassPathBeanDefinitionScanner</span> <span style=color:#8be9fd;font-style:italic>extends</span> ClassPathScanningCandidateComponentProvider <span style=color:#ff79c6>{...}</span>
</span></span></code></pre></div><p>翻译一下：</p><blockquote><p>一个 bean 定义扫描器，用于检测类路径上的 bean 的候选者，将相应的 bean 定义注册到给定的注册表（ BeanFactory 或 ApplicationContext ）。
通过可配置的类型过滤器检测候选类。默认过滤器包括使用 Spring 的@Component 、 @Repository 、 @Service 或@Controller 原型注释的类。
如果可用，还支持 Java EE 6 的 javax.annotation.ManagedBean 和 JSR-330 的 javax.inject.Named 注释。</p></blockquote><p>它的意思说，把类路径中的所有类进行扫描。把类中配置的 bean 放到注册表， 注册表可能是 <code>BeanFactory</code> 或者 <code>ApplicationContext</code></p><p>到这里可以知道， <code>AnnotationConfigApplicationContext</code> 除了继承父类的属性外，还初始化了 1. bean 定义读取器(reader) 2. bean 定义扫描器 (scanner)</p><p>下面看一下如何初始化的：</p><h2 id=初始化-annotatedbeandefinitionreader>初始化 AnnotatedBeanDefinitionReader</h2><p>一层层进入 <code>new AnnotatedBeanDefinitionReader(this)</code>, 最终找到方法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    * Register all relevant annotation post processors in the given registry.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    * @param registry the registry to operate on
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    * @param source the configuration source element (already extracted)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    * that this registration was triggered from. May be {@code null}.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    * @return a Set of BeanDefinitionHolders, containing all bean definitions
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    * that have actually been registered by this call
</span></span></span><span style=display:flex><span><span style=color:#6272a4>    */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> Set<span style=color:#ff79c6>&lt;</span>BeanDefinitionHolder<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>registerAnnotationConfigProcessors</span><span style=color:#ff79c6>(</span>
</span></span><span style=display:flex><span>        BeanDefinitionRegistry registry<span style=color:#ff79c6>,</span> @Nullable Object source<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    DefaultListableBeanFactory beanFactory <span style=color:#ff79c6>=</span> unwrapDefaultListableBeanFactory<span style=color:#ff79c6>(</span>registry<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>beanFactory <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!(</span>beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getDependencyComparator</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>instanceof</span> AnnotationAwareOrderComparator<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>            beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setDependencyComparator</span><span style=color:#ff79c6>(</span>AnnotationAwareOrderComparator<span style=color:#ff79c6>.</span><span style=color:#50fa7b>INSTANCE</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!(</span>beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getAutowireCandidateResolver</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>instanceof</span> ContextAnnotationAutowireCandidateResolver<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>            beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setAutowireCandidateResolver</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>new</span> ContextAnnotationAutowireCandidateResolver<span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Set<span style=color:#ff79c6>&lt;</span>BeanDefinitionHolder<span style=color:#ff79c6>&gt;</span> beanDefs <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedHashSet<span style=color:#ff79c6>&lt;&gt;(</span>8<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!</span>registry<span style=color:#ff79c6>.</span><span style=color:#50fa7b>containsBeanDefinition</span><span style=color:#ff79c6>(</span>CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        RootBeanDefinition def <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> RootBeanDefinition<span style=color:#ff79c6>(</span>ConfigurationClassPostProcessor<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        def<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setSource</span><span style=color:#ff79c6>(</span>source<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        beanDefs<span style=color:#ff79c6>.</span><span style=color:#50fa7b>add</span><span style=color:#ff79c6>(</span>registerPostProcessor<span style=color:#ff79c6>(</span>registry<span style=color:#ff79c6>,</span> def<span style=color:#ff79c6>,</span> CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME<span style=color:#ff79c6>));</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!</span>registry<span style=color:#ff79c6>.</span><span style=color:#50fa7b>containsBeanDefinition</span><span style=color:#ff79c6>(</span>AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        RootBeanDefinition def <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> RootBeanDefinition<span style=color:#ff79c6>(</span>AutowiredAnnotationBeanPostProcessor<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        def<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setSource</span><span style=color:#ff79c6>(</span>source<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        beanDefs<span style=color:#ff79c6>.</span><span style=color:#50fa7b>add</span><span style=color:#ff79c6>(</span>registerPostProcessor<span style=color:#ff79c6>(</span>registry<span style=color:#ff79c6>,</span> def<span style=color:#ff79c6>,</span> AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME<span style=color:#ff79c6>));</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// .... 省略很多代码
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> beanDefs<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>先翻译一下这个方法的注释，以及参数和返回值:</p><p><strong>注释:</strong></p><blockquote><p>在给定的注册表中注册所有相关的注解后处理器</p></blockquote><p><strong>参数:</strong></p><ol><li>第一个参数是： <code>register</code>, 这个是从最开始传入的 <code>AnnotationConfigApplicationContext</code> 对象</li><li>第二个参数是：<code>Object source</code> 这个传入的 null, 暂不关心它</li></ol><p><strong>返回值:</strong></p><p>返回的是 <code>Set&lt;BeanDefinitionHolder></code> 集合，到这里先暂停一下，需要看 <code>BeanDefinitionHolder</code> 是什么，它里面都是什么属性，以及干嘛用的：</p><h3 id=beandefinition>BeanDefinition</h3><p>进入这个类，查看它的注释和内部结构:
通过注释可以知道它是 <strong>具有名称和别名的 BeanDefinition 的持有者</strong></p><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/2022-11-08-16-12-20.png alt></p><p>由此可知道关键信息不在它，而是 <code>BeanDefinition</code>, <code>BeanDefinitionHolder</code> 只是 <code>BeanDefinition</code> 的持有者，只比 <code>BeanDefinition</code> 多了 <code>beanName</code> 以及别名属性。为的是可以有一个具体的名称来描述 <code>BeanDefinition</code>. 所以要接着看 <code>BeanDefinition</code>：</p><p>先看翻译下 <code>BeanDefinition</code> 的注释:</p><blockquote><p>BeanDefinition 描述了一个 bean 实例，它具有属性值、构造函数参数值以及具体实现提供的更多信息。 这只是一个最小接口：主要目的是允许像PropertyPlaceholderConfigurer这样的BeanFactoryPostProcessor内省和修改属性值和其他 bean 元数据。</p></blockquote><p>它说 BeanDefinition <strong>描述了</strong> bean 的实例。也就是建筑图纸和建筑物的关系，BeanDefinition 会存有 某个bean 的字段，构造方法等等。可以根据 BeanDefinition 构造出应的bean。就如同可以通过建筑图纸还原出建筑物一样。</p><p>这里就非常巧妙了，一个系统中的有各式各样的bean，功能不同，类型不同。用一个相同的东西去描述，操作这些bean，是一个非常有利的转换。因为它们都是对象，是对象就会有方法，字段，类型。把这些方法，字段，类型再抽象，聚合就形成了 BeanDefinition.</p><p>看一下 BeanDefinition 内部结构:</p><p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/2022-11-08-16-40-24.png alt></p><p>内容很多，都是设置，获取 某个对象类型信息的，挑几个看一下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>interface</span> <span style=color:#50fa7b>BeanDefinition</span> <span style=color:#8be9fd;font-style:italic>extends</span> AttributeAccessor<span style=color:#ff79c6>,</span> BeanMetadataElement <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 标准单例范围的范围标识符：“单例”。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	String SCOPE_SINGLETON <span style=color:#ff79c6>=</span> ConfigurableBeanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>SCOPE_SINGLETON</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 标准原型范围的范围标识符：“原型”。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  	String SCOPE_PROTOTYPE <span style=color:#ff79c6>=</span> ConfigurableBeanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>SCOPE_PROTOTYPE</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 指定此 bean 定义的 bean 类名。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 类名可以在 bean 工厂后期处理期间修改，通常用它的解析变体替换原始类名。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setBeanClassName</span><span style=color:#ff79c6>(</span>@Nullable String beanClassName<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 覆盖此 bean 的目标范围，指定一个新的范围名称
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setScope</span><span style=color:#ff79c6>(</span>@Nullable String scope<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//设置这个 bean 是否应该被延迟初始化。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//如果为false ，则 bean 将在启动时由执行单例预初始化的 bean 工厂实例化。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setLazyInit</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>boolean</span> lazyInit<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//返回此 bean 是否应该延迟初始化，即在启动时不急切地实例化。仅适用于单例 bean。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isLazyInit</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ....
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>好了，对 BeanDefinition 的了解暂时到此。不再深入了。继续上面的<code> registerAnnotationConfigProcessors</code>方法:</p><p>第一行： <code>DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</code></p><p>进入方法后，发现没有做太多的是事情，就是把注册器的 beanFactory 包装一下，再返回。这里的 register 就是最开始 main 方法中的 <code>AnnotationConfigApplicationContext</code> 对象。</p><p>接着看下面：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>beanFactory <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!(</span>beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getDependencyComparator</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>instanceof</span> AnnotationAwareOrderComparator<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setDependencyComparator</span><span style=color:#ff79c6>(</span>AnnotationAwareOrderComparator<span style=color:#ff79c6>.</span><span style=color:#50fa7b>INSTANCE</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!(</span>beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getAutowireCandidateResolver</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>instanceof</span> ContextAnnotationAutowireCandidateResolver<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        beanFactory<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setAutowireCandidateResolver</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>new</span> ContextAnnotationAutowireCandidateResolver<span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>对 beanFactory 添加 <code>依赖比较器</code> 和 <code>Autowire 候选解析器</code> 暂时不知道设么作用，跳过。继续：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Set<span style=color:#ff79c6>&lt;</span>BeanDefinitionHolder<span style=color:#ff79c6>&gt;</span> beanDefs <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> LinkedHashSet<span style=color:#ff79c6>&lt;&gt;(</span>8<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(!</span>registry<span style=color:#ff79c6>.</span><span style=color:#50fa7b>containsBeanDefinition</span><span style=color:#ff79c6>(</span>CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    RootBeanDefinition def <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> RootBeanDefinition<span style=color:#ff79c6>(</span>ConfigurationClassPostProcessor<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    def<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setSource</span><span style=color:#ff79c6>(</span>source<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    beanDefs<span style=color:#ff79c6>.</span><span style=color:#50fa7b>add</span><span style=color:#ff79c6>(</span>registerPostProcessor<span style=color:#ff79c6>(</span>registry<span style=color:#ff79c6>,</span> def<span style=color:#ff79c6>,</span> CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME<span style=color:#ff79c6>));</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>先构造了一个 <code>BeanDefinitionHolder</code> 的集合，也就是这个方法要返回的集合，if 语句中， 判断注册器是否包含某个 BeanDefinition, 进去看一下怎么判断的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#6272a4>// 在 DefaultListableBeanFactory 类下面
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	@Override
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>containsBeanDefinition</span><span style=color:#ff79c6>(</span>String beanName<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		Assert<span style=color:#ff79c6>.</span><span style=color:#50fa7b>notNull</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;Bean name must not be null&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>beanDefinitionMap</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>containsKey</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>最终会进入 <code>DefaultListableBeanFactory</code> 类中的 <code>containsBeanDefinition</code> 方法，也就是说这个方法不是注册器提供的，而是它的 beanFactory 属性提供的。并且在 beanFactory 中有一个 <code>Map&lt;String, BeanDefinition> beanDefinitionMap</code>；通过名字就可以知道，存放的是 BeanDefinition, 判断注册器是否包已经包含某个 BeanDefinition,就是看这个 map 是否包含相应的key了。这个功能是由它所辖的 beanFactory 实现的。这也比较符合常理： bean 工厂去管理 bean定义。到这里就可以猜测出注册 bean时,也是放入这个Map, 取出 bean 时，也是从这个 Map 中获取。</p><p>再看一下传入的 key 是什么:
<code>CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME</code> 是写死在源码中的常量: <code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code> 某个类的全名称。继续向下看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RootBeanDefinition def <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> RootBeanDefinition<span style=color:#ff79c6>(</span>ConfigurationClassPostProcessor<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>def<span style=color:#ff79c6>.</span><span style=color:#50fa7b>setSource</span><span style=color:#ff79c6>(</span>source<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>beanDefs<span style=color:#ff79c6>.</span><span style=color:#50fa7b>add</span><span style=color:#ff79c6>(</span>registerPostProcessor<span style=color:#ff79c6>(</span>registry<span style=color:#ff79c6>,</span> def<span style=color:#ff79c6>,</span> CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME<span style=color:#ff79c6>));</span>
</span></span></code></pre></div><p>将 <code>ConfigurationClassPostProcessor.class</code> 作为参数，构造了一个 RootBeanDefinition , 查看类关系，发现 RootBeanDefinition 是 BeanDefinition 的一个实现类。这里只需明白把一个 class 转成了 BeanDefinition就行了。至于怎么转的，可以自行查看</p><p><code>def.setSource(source)</code> 刚刚说过 source 参数是 null, 先跳过。不深究它是什么意思。</p><p>再看 <code>registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)</code> 这一行，方法名是 <code>注册后置处理器</code>， 把注册器，BeanDefinition, 和 类全名作为参数传入方法，再一路跟踪下去发现最后还是进入了 DefaultListableBeanFactory 类。执行的是 <code>registerBeanDefinition</code> 方法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@Override
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>registerBeanDefinition</span><span style=color:#ff79c6>(</span>String beanName<span style=color:#ff79c6>,</span> BeanDefinition beanDefinition<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>throws</span> BeanDefinitionStoreException <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Assert<span style=color:#ff79c6>.</span><span style=color:#50fa7b>hasText</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;Bean name must not be empty&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    Assert<span style=color:#ff79c6>.</span><span style=color:#50fa7b>notNull</span><span style=color:#ff79c6>(</span>beanDefinition<span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;BeanDefinition must not be null&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 省略很多校验性代码
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    BeanDefinition existingDefinition <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>beanDefinitionMap</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>get</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>existingDefinition <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 省略很多校验性代码
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>beanDefinitionMap</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>put</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>,</span> beanDefinition<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 检查这个工厂的bean创建阶段是否已经开始，即在此期间是否有任何bean被标记为已创建。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>hasBeanCreationStarted<span style=color:#ff79c6>())</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>//... 省略暂不会执行的代码
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Still in startup registration phase: 仍处于启动注册阶段
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// beanName 作为key, beanDefinition 是 value, 这些都是参数传入的
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>beanDefinitionMap</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>put</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>,</span> beanDefinition<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// bean 工厂还维护了所有的 beanName，有序的
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>beanDefinitionNames</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>add</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 不懂，先跳过
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>manualSingletonNames</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>remove</span><span style=color:#ff79c6>(</span>beanName<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 不懂。先跳过
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>frozenBeanDefinitionNames</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 省略后置代码, 先跳过
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>从上面代码可知，注册 BeanDefinition 也是有注册器的 beanFactory 实现的。还记得 <code>AnnotatedBeanDefinitionReader</code> 这个类的注释说道：<code>用于注解 bean 类的编程注册。这是ClassPathBeanDefinitionScanner的替代方案，应用相同的注解，但仅适用于显式注册的类</code>. <strong>显示注册</strong> 就是手动把事先定义好的类添加到 beanDefinitionMap。 那么猜测一下 <code>ClassPathBeanDefinitionScanner</code> 是不是自动扫描我们系统自定义的类，然后把我们自定义类自动添加到 beanDefinitionMap 中的。比如被 @Service @Controller @Bean 修饰的类。我们使用Spring时，可没有把这些类向bean工厂手动注册</p><p>这个方法的后面还注册了很多其他内置的类。就不一一罗列了。之后这个方法就结束了。</p><p>总结一下 <code>this.reader = new AnnotatedBeanDefinitionReader(this);</code> 都干了哪些事情:</p><ol><li>new 一个 <code>AnnotatedBeanDefinitionReader</code> Bean 定义读取类</li><li>在 new 的过程中，把 spring 内置的各种类注册到 beanDefinitionMap 中。</li></ol><p>从这个方法中我们可以知道：</p><ol><li>AnnotationConfigApplicationContext 中有 AnnotatedBeanDefinitionReader 类型的属性</li><li>BeanDefinition 是用来描述各种bean的类，类似建筑图纸和建筑物的关系</li><li>BeanDefinitionHolder 只是 BeanDefinition 的持有者，相当于为 BeanDefinition 增加了名称和别名</li><li>AnnotationConfigApplicationContext 中有 beanFactory, beanDefinition 的注册都是由 beanFactory 完成的。</li><li>BeanFactory 中有 beanDefinitionMap, 用来存放 beanDefinition.</li><li>BeanFactory 中还有 beanDefinitionNames, 存放所有的 beanDefinition 的名称</li></ol><p>目前为止我们只知道向注册器中注册了一堆内置的类。还没有看到这些类的用法， 大胆猜测一下，这些内置类是一些创世纪的类，后面用到的类扫描，属性注入，切面等，可能都是由这些类实现的。</p><h2 id=初始化-classpathbeandefinitionscanner>初始化 ClassPathBeanDefinitionScanner</h2><h2 id=注册配置类>注册配置类</h2><h2 id=refresh-方法>refresh 方法</h2><h3 id=heading></h3></div><div class=article-toc><h3></h3><nav id=TableOfContents><ul><li><a href=#new-annotationconfigapplicationcontext>new AnnotationConfigApplicationContext()</a></li><li><a href=#初始化-annotatedbeandefinitionreader>初始化 AnnotatedBeanDefinitionReader</a><ul><li><a href=#beandefinition>BeanDefinition</a></li></ul></li><li><a href=#初始化-classpathbeandefinitionscanner>初始化 ClassPathBeanDefinitionScanner</a></li><li><a href=#注册配置类>注册配置类</a></li><li><a href=#refresh-方法>refresh 方法</a><ul><li><a href=#heading></a></li></ul></li></ul></nav></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/java>java</a></li><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/spring>spring</a></li></ul></footer></div><nav id=article-nav><a href=../../posts/ioc%E6%80%9D%E6%83%B3%E8%AE%B2%E8%A7%A3%E5%92%8C%E5%AE%9E%E7%8E%B0/ id=article-nav-newer class=article-nav-link-wrap><div class=article-nav-title><span>&lt;</span>&nbsp;
IoC 思想和实现</div></a><a href=../../posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>自定义注解&nbsp;<span>></span></div></a></nav></article></section><div><script src=https://utteranc.es/client.js repo=dccmmtop/dccmmtop.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></div><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022 dc<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script><script>document.getElementById("main-nav-toggle").addEventListener("click",function(){var e=document.getElementById("header");e.classList.contains("mobile-on")?e.classList.remove("mobile-on"):e.classList.add("mobile-on")})</script></footer></div></body></html>