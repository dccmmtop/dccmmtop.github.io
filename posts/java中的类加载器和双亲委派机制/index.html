<!doctype html><html><head><title>java中的类加载器和双亲委派机制 // 超的博客</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="java中的类加载器和双亲委派机制"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:locale" content="zh"><meta property="og:url" content="https://dccmmtop.github.io/posts/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"><link rel=icon type=image/x-icon href=../../favicon.ico><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<link href=https://dccmmtop.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://dccmmtop.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://dccmmtop.github.io/css/style.css><link rel=stylesheet href=https://dccmmtop.github.io/css/custom.css><link rel=stylesheet href=https://dccmmtop.github.io/css/copy-to-clipboard.css><script src=https://dccmmtop.github.io/js/fastsearch.js></script>
<script src=https://dccmmtop.github.io/js/fuse.js></script>
<script src=https://dccmmtop.github.io/js/custom.js></script>
<script src=https://dccmmtop.github.io/js/copy-to-clipboard.js></script><meta name=generator content="Hugo 0.101.0"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=https://dccmmtop.github.io/>超的博客</a><nav id=main-nav><a class=main-nav-link href=../../posts/>文章</a>
<a class=main-nav-link href=../../tags/>标签</a>
<a class=main-nav-link href=../../about/>关于</a>
<a class=main-nav-link id=search><input id=inputSearch placeholder=search><svg t="1634282825021" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="2401" width="15" height="15"><path d="M1005.312 914.752 806.784 716.288A448 448 0 100 448a448 448 0 00716.288 358.784l198.4 198.4a64 64 0 1090.624-90.432zM448 767.936A320 320 0 11448 128a320 320 0 010 640z" fill="#262626" p-id="2402"/></svg></a></nav><nav id=sub-nav><div id=search-form-wrap></div></nav></div></div><div class="modal fade" id=exampleModal tabindex=-1 role=dialog aria-labelledby=exampleModalLabel aria-hidden=true><div class=modal-dialog role=document><div class=modal-content><div class=modal-header><h5 class=modal-title id=exampleModalLabel>搜索结果</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class="modal-body searchResults"></div></div></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>java中的类加载器和双亲委派机制</h1></header><div class=article-meta><a href=../../posts/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/ class=article-date><time datetime=2022-08-14T14:03:08.000+00:00 itemprop=datePublished>2022-08-14</time></a></div><div class=article-entry itemprop=articleBody><h2 id=类加载是什么>类加载是什么</h2><p>把磁盘中的java文件加载到内存中的过程叫做类加载</p><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到JVM. 有如下 User 类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>package</span> dc.dccmmtop<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> Class User <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>main</span><span style=color:#ff79c6>(</span>String<span style=color:#ff79c6>[]</span> args<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>运行 <code>java dc.dccmmtop.User</code> 时， 先要找到 User.Class 文件，查找全路径就是 Class_PATH + {{package name}}，对于User类来说，就是 <code>{$Class_APTH}/dc/dccmmtop.User.Class</code></p><p>假如 <code>User.java</code> 在<code>F:\code</code>, 并且不在Class_PATH 下，可以通过 <code>java -Classpath "F:\code"</code> 临时指定。</p><p>加载类之后还有后续的步骤:</p><ol start=2><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>这篇文章主要来讲讲类加载</p><h2 id=类加载器>类加载器</h2><p>不了解类加载机制的，可能就认为，只需找到java文件所在的磁盘位置，然后进行一次读文件的操作不就完成了加载嘛，其实远非如此。</p><p>总有一个加载类的工具，这个工具叫做类加载器，在java代码中可以通过如下方式获取当前类的类加载器是什么</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>package</span> dccmmtop<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> Class User <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>main</span><span style=color:#ff79c6>(</span>String<span style=color:#ff79c6>[]</span> args<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;hello&#34;</span><span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>User<span style=color:#ff79c6>.</span><span style=color:#50fa7b>Class</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getClassLoader</span><span style=color:#ff79c6>());</span> 
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814161928.png><p>如图可以看到类加载器的名字叫做 <code>AppClassLoader</code></p><p>我们全局搜索一下这个类，会发现在 <code>sun.misc.Launcher.java</code> 文件中找到。
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814162204.png></p><p>那么这个<code>AppClassLoader</code> 本身也是一个 java 文件，它又是什么时候被加载并初始化的呢？</p><p>我们滚动到文件顶部，看到 Launcher 类的构造方法部分：</p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814162903.png><p>标记1 和标记2 实现了一个单例模式，在5 处获取到了 <code>AppClassLoader</code> 实例。也就是说在某一个地方通过调用 Launcher 类中的 <code>getLauncher()</code> 方法，会得到 <code>AppClassLoader</code> 实例， 那么 <code>getLauncher()</code> 方法又是在哪里调用的呢？追踪到这里已经无法在java代码中找到上一步了，其实这个方法是jvm (c++实现)调用的，如下图:</p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/20220814_172637.png><p>以上就是类加载的主要步骤了。下面看一下双亲委派机制</p><h2 id=双亲委派机制>双亲委派机制</h2><p>我们继续看<code>AppClassLoader</code> 实例化的过程：</p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814162903.png><p>在5处，实例化了一个<code>AppClassLoader</code>的对象，同时传进去了一个参数 <code>var1</code>, 这个 var1 是另外一个类加载器<code>ExtClassLoader</code> , 我们在进入 <code>getAppClassLoader</code> 方法看一看是怎么实现的：</p><p>先看一下 几个ClassLoad的继承关系：</p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814173936.png>
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814174228.png><p>有上面的继承关系图可以看出来，<code>AppClassLoader</code> 和 <code>ExtClassLoader</code> 都是从 <code>ClassLoader</code> 继承来的。</p><p>在 <code>Launcher()</code> 中可知，调用 <code>AppClassLoader.getAppClassLoader()</code> 方法时， 把 <code>ExtClassLoader</code> 的实例作为参数传递进来，最终到4这一步，作为 var2 参数，调用父类的构造方法，继续追踪父类的构造方法直到 <code>ClassLoader</code> :
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814175026.png></p><p>在 <code>ClassLoader</code> 构造方法中，维护了一个 parent 变量，到此我们知道了 <code>AppClassLoader</code> 中 parent 变量保存的是 <code>ExtClassLoader</code>的实例, 如下图表示</p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814175857.png><p>继续看Launcher 构造方法：
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814180135.png></p><p><code>loadClass()</code> 方法将 Class 文件加载到jvm中，我们跟踪一下这个方法，会发现最后会调到 根类<code>ClassLoader</code> 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>protected</span> Class<span style=color:#ff79c6>&lt;?&gt;</span> loadClass<span style=color:#ff79c6>(</span>String name<span style=color:#ff79c6>,</span> <span style=color:#8be9fd>boolean</span> resolve<span style=color:#ff79c6>)</span>  
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>throws</span> ClassNotFoundException  
</span></span><span style=display:flex><span><span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>synchronized</span> <span style=color:#ff79c6>(</span>getClassLoadingLock<span style=color:#ff79c6>(</span>name<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// First, check if the Class has already been loaded  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        Class<span style=color:#ff79c6>&lt;?&gt;</span> c <span style=color:#ff79c6>=</span> findLoadedClass<span style=color:#ff79c6>(</span>name<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>long</span> t0 <span style=color:#ff79c6>=</span> System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>nanoTime</span><span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>try</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>parent <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>                    c <span style=color:#ff79c6>=</span> parent<span style=color:#ff79c6>.</span><span style=color:#50fa7b>loadClass</span><span style=color:#ff79c6>(</span>name<span style=color:#ff79c6>,</span> <span style=color:#ff79c6>false</span><span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>                    c <span style=color:#ff79c6>=</span> findBootstrapClassOrNull<span style=color:#ff79c6>(</span>name<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>catch</span> <span style=color:#ff79c6>(</span>ClassNotFoundException e<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// ClassNotFoundException thrown if Class not found  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#6272a4>// from the non-null parent Class loader            }  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// If still not found, then invoke findClass in order  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#6272a4>// to find the Class.                long t1 = System.nanoTime();  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                c <span style=color:#ff79c6>=</span> findClass<span style=color:#ff79c6>(</span>name<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// this is the defining Class loader; record the stats  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                sun<span style=color:#ff79c6>.</span><span style=color:#50fa7b>misc</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>PerfCounter</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getParentDelegationTime</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>addTime</span><span style=color:#ff79c6>(</span>t1 <span style=color:#ff79c6>-</span> t0<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>                sun<span style=color:#ff79c6>.</span><span style=color:#50fa7b>misc</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>PerfCounter</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getFindClassTime</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>addElapsedTimeFrom</span><span style=color:#ff79c6>(</span>t1<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>                sun<span style=color:#ff79c6>.</span><span style=color:#50fa7b>misc</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>PerfCounter</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getFindClasses</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>increment</span><span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>resolve<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>            resolveClass<span style=color:#ff79c6>(</span>c<span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> c<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>上面代码块中的弟6行，<code>findLoadedClass()</code> , 先从已加载到的类集合中查找有没有这个类，如果有的话，直接返回，没有再进行下一步, <code>findLoadedClass</code> 方法源码如下</p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814180936.png><p>到 <code>native finnal Class&lt;?> findLoadedClass0(String name);</code> 这里已经无法在向后追踪了，看到 <code>naive</code> ,要明白 使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用.</p><p>此时 User.Class 是第一次加载，<code>AppClassLoader</code> 中肯定无法在已加载的集合中找到，所以继续向下走到第 10，11 行. 上面已经分析过，<code>AppClassLoader</code> 中的 parent 是 <code>ExtClassLoader</code> , 所以在11行由 <code>ExtClassLoader</code> 的实例执行 <code>laodClass</code> 方法。 <code>ExtClassLoader</code> 没有覆写根类<code>ClassLoader</code> 的<code>loaderClass</code> 方法，所以也会到这里，只不过 <code>ExtClassLoader</code> 的 parent 是 NUll， 会走到13行，调用<code>findBootstrapClassOrNull()</code> 方法，再看一下这个方法的实现:</p><img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814182402.png>
会发现这个方法也是C++实现的，虽然我们无法看到源码，但是根据注释可以知道，这个是保存了启动类加载器加载过的类。<p>到此为止，我们已经见识过3中不同的类加载器了：</p><ul><li>AppClassLoader</li><li>ExtClassLoader</li><li>BootStrapClassLoader</li></ul><p>我们先不管这个后面两个类加载器是什么， 假定他们也找不到 User.Class. 继续向下看：</p><p>执行到第21行<code>findClas()</code>这里，再看源码
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814183820.png></p><p>在A-2 这一步，<code>ucp</code> 其实保存的就是当前 ClassLoader 的类加载路径，就不再展开。要记住此时的 ClassLoader 是 <code>ExtClassLoader</code>, 假如仍然找不到User.Class 会执行到 A-3.然后返回到 loadClass 方法中， 此时 c 是空，继续执行到33行，返回到 <code>AppClassLoader</code> 调用 <code>parent.getAppClassLoader</code> 处，在 <code>AppClassLoader</code> 实例的范围下继续向后执行，然后再继续调用 <code>findClass</code> 方法，如果在<code>AppClassLoader</code>的类加载路径中找到User.Class 文件，就会 执行 <code>defindClass(name,res)</code> 方法去加载类文件了。</p><p>整个过程用文字描述起来比较复杂，来张图就很清楚了，为什么叫做双亲委派：
<img src=https://raw.githubusercontent.com/dccmmtop/notebook/master/images/Pasted%20image%2020220814190435.png></p><p>把 loadedClassList 集合称作缓存</p><ol><li>先在 AppClassLoader 中缓存中找，如果找不到向 ExtClassLoader 找，如果能找到，直接返回</li><li>在 ExtClassLoader 中缓存找，如果找不到向 BootStrapClassLoader 找，如果能找到，直接返回</li><li>在 BootStrapClassLoader 找，如果找不到， 在 ExtClassLoader 类路径集合中找，</li><li>如果在 ExtClassLoader 类路径集合找不到，在 AppClassLoader 类路径集合找</li><li>如果在 AppClassLoader 类路径集合中能找到，加载该类，并放入缓存。找不到则报错</li></ol><p>双亲指的是 <code>ExtClassLoader</code> 和 <code>BootStrapClassLoader</code>， AppClassLoader 先不加载，而是向上让其“父”加载，父加载不到时，自己再加载。这里的父不是父类，而是调用层级的关系。</p><p>是时候介绍一下 这三个类加载器</p><h3 id=bootstrapclassloader>BootStrapClassLoader</h3><p>引导类加载器</p><p>负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等</p><h3 id=extclassloader>ExtClassLoader</h3><p>扩展类加载器</p><p>负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包</p><h3 id=appclassloader>AppClassLoader</h3><p>应用程序加载器</p><p>负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</p><p>我们可以写代码验证一下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>package</span> dccmmtop<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> sun.misc.Launcher<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> java.net.URL<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> Class User <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>main</span><span style=color:#ff79c6>(</span>String<span style=color:#ff79c6>[]</span> args<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>String<span style=color:#ff79c6>.</span><span style=color:#50fa7b>Class</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getClassLoader</span><span style=color:#ff79c6>());</span> <span style=color:#6272a4>// null  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>com<span style=color:#ff79c6>.</span><span style=color:#50fa7b>sun</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>crypto</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>provider</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>DESKeyFactory</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>Class</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getClassLoader</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>getClass</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>getName</span><span style=color:#ff79c6>());</span> <span style=color:#6272a4>//sun.misc.Launcher$ExtClassLoader  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>User<span style=color:#ff79c6>.</span><span style=color:#50fa7b>Class</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getClassLoader</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>getClass</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>getName</span><span style=color:#ff79c6>());</span> <span style=color:#6272a4>// sun.misc.Launcher$AppClassLoader  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;bootstrapLoader加载以下文件：&#34;</span><span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>        URL<span style=color:#ff79c6>[]</span> urls <span style=color:#ff79c6>=</span> Launcher<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getBootstrapClassPath</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>getURLs</span><span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0<span style=color:#ff79c6>;</span> i <span style=color:#ff79c6>&lt;</span> urls<span style=color:#ff79c6>.</span><span style=color:#50fa7b>length</span><span style=color:#ff79c6>;</span> i<span style=color:#ff79c6>++)</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>            System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>urls<span style=color:#ff79c6>[</span>i<span style=color:#ff79c6>]);</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;extClassloader加载以下文件：&#34;</span><span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getProperty</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;java.ext.dirs&#34;</span><span style=color:#ff79c6>));</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>();</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;appClassLoader加载以下文件：&#34;</span><span style=color:#ff79c6>);</span>  
</span></span><span style=display:flex><span>        System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getProperty</span><span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;java.Class.path&#34;</span><span style=color:#ff79c6>));</span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>输入如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>null // 因为调用了 c++ 实现。无法获取到java对象
</span></span><span style=display:flex><span>sun.misc.Launcher$ExtClassLoader
</span></span><span style=display:flex><span>sun.misc.Launcher$AppClassLoader
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>the bootstrapLoader : null
</span></span><span style=display:flex><span>the extClassloader : sun.misc.Launcher$ExtClassLoader@77459877
</span></span><span style=display:flex><span>the appClassLoader : sun.misc.Launcher$AppClassLoader@18b4aac2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bootstrapLoader加载以下文件：
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/lib/resources.jar
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/lib/rt.jar
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/lib/sunrsasign.jar
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/lib/jsse.jar
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/lib/jce.jar
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/lib/charsets.jar
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/lib/jfr.jar
</span></span><span style=display:flex><span>file:/C:/Program%20Files/Java/jdk1.8.0_261/jre/Classes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>extClassloader加载以下文件：
</span></span><span style=display:flex><span>C:\Program Files\Java\jdk1.8.0_261\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>appClassLoader加载以下文件：
</span></span><span style=display:flex><span>C:\Program Files\Java\jdk1.8.0_261\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_261\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_261\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_261\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_261\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_261\jre\lib\ext\jaccess.jar;...省略
</span></span></code></pre></div><h3 id=为什么使用双亲委派机制>为什么使用双亲委派机制</h3><ol><li><p>沙箱安全机制：
自己写的java.lang.String.Class类不会被加载，这样便可以防止核心 API库被随意篡改</p></li><li><p>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一 次，保证被加载类的唯一性</p></li></ol><h3 id=全盘负责委托机制>全盘负责委托机制</h3><p>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类<br>所依赖及引用的类也由这个ClassLoder载入</p><h2 id=自定义类加载器>自定义类加载器</h2><p>待续&mldr;</p><h2 id=打破双亲委派机制>打破双亲委派机制</h2><p>待续&mldr;</p></div><div class=article-toc><h3></h3><nav id=TableOfContents><ul><li><a href=#类加载是什么>类加载是什么</a></li><li><a href=#类加载器>类加载器</a></li><li><a href=#双亲委派机制>双亲委派机制</a><ul><li><a href=#bootstrapclassloader>BootStrapClassLoader</a></li><li><a href=#extclassloader>ExtClassLoader</a></li><li><a href=#appclassloader>AppClassLoader</a></li><li><a href=#为什么使用双亲委派机制>为什么使用双亲委派机制</a></li><li><a href=#全盘负责委托机制>全盘负责委托机制</a></li></ul></li><li><a href=#自定义类加载器>自定义类加载器</a></li><li><a href=#打破双亲委派机制>打破双亲委派机制</a></li></ul></nav></div><footer class=article-footer><ul class=article-tag-list><li class=article-tag-list-item><a class=article-tag-list-link href=https://dccmmtop.github.io/tags/java>java</a></li></ul></footer></div><nav id=article-nav><a href=../../posts/finalize%E7%9A%84%E6%84%8F%E4%B9%89/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>finalize的意义&nbsp;<span>></span></div></a></nav></article></section><footer id=footer><div class=outer><div id=footer-info class=inner>&copy; 2022 dc<br>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a></div></div><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script><script>document.getElementById("main-nav-toggle").addEventListener("click",function(){var e=document.getElementById("header");e.classList.contains("mobile-on")?e.classList.remove("mobile-on"):e.classList.add("mobile-on")})</script></footer></div></body></html>